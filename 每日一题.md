# 八月

## 8.23 resister关键字

当对一个变量频繁被读写时，需要反复访问内存，从而花费大量的存取时间。为此，C语言提供了一种变量，即寄存器变量。这种变量存放在CPU的寄存器中，使用时，不需要访问内存，而直接从寄存器中读写，从而提高效率。寄存器变量的说明符是register。对于循环次数较多的循环控制变量及循环体内反复使用的变量均可定义为寄存器变量，而循环计数是应用寄存器变量的最好候选者。



(1) 只有局部自动变量和形参才可以定义为寄存器变量。因为寄存器变量属于动态存储方式，凡需要采用静态存储方式的量都不能定义为寄存器变量，包括：模块间全局变量、模块内全局变量、局部static变量;



(2) register是一个"建议"型关键字，意指程序建议该变量放在寄存器中，但最终该变量可能因为条件不满足并未成为寄存器变量，而是被放在了存储器中，但编译器中并不报错(在C++语言中有另一个"建议"型关键字：inline)。





## 8.24 数组的[]原理

分析下列代码的输出结果：

```c
int array[10]={0};
0[array] = 1;
printf("%d",(-5)[array+5]);
```

结果是输出：1

因为==array[2]可以看作`*(array+2)`==，所以`(-5)[array+5]`就相当于`*(-5+array+5)`，也就是`*(array+0)`。

所以，尽量使用指针代替数组， ==指针方法的优点是，array的地址每次装入地址p后，在每次循环中只需对p增量操作。在数组索引方法中，每次循环中都必须进行基于t值求数组下标的复杂运算 。==





##  8.25 static作用

Static是C的一个关键字，根据其修饰的对象属性不同可以分为两种用途：

1.修饰存储类型，使之成为静态存储类型

2.修饰链接属性，使之成为内部链接属性

==静态存储类型：==

当修饰在函数内部定义的局部变量时，这个局部变量就存储在函数的内存静态区，函数运行结束后也不会销毁这个局部变量的值，**函数下次运行的时候依然可以使用上次运行后的变量的值**。

当修饰全局变量的时候，此时的全局变量就是静态全局变量，**该变量的作用域只能够限制在定义该变量的文件中，而且其他文件不能够通过extern关键字来引用**。



==内部链接属性：==

 静态函数只能在声明它的源文件中使用 。



例子：

<img src="../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/1598447864338.png" alt="1598447864338" style="zoom:200%;" />



<img src="../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/1598447846912.png" alt="1598447846912" style="zoom:200%;" />



## 8.26 字符串结束问题

判断如下程序输出的值：

```c
char c[][8]={"apple","orange","banana"};
  
printf("%d,",sizeof(c));
printf("%d",strlen(c));
```

这涉及到sizeof和strlen的区别：

* sizeof是判断类型占用的大小，取决于数据类型
* strlen是判断字符串长度的，遇到字符串结束符‘\0’的时候就结束了，所以结果取决于‘\0’的位置



所以对于

```c
char c[][8]={"apple","orange","banana"};
```

三个元素，每个元素的空间是8个字节，所以sizeof(c)输出的是8*3=24

然鹅，对于strlen，在第一个字符串元素“apple”的末尾就遇到了‘\0’，所以在第一个字符串元素结束后就会结束判断，所以最终结果是apple这五个字符的长度，即5

图示：
![1598450805538](../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/1598450805538.png)





## 8.27 const用法

const具有左结合性，即通常：const + 修饰变量



对于const的用法，程序如下：

```c
int tmp = 66;
int *const age = &tmp;
int newage = 23;
```

执行的语句如下：

```c
*age=newage;
age = &newage;
```

问题：判断哪个语句是正确的，为什么？

分析：

第一条代码：创建一个int型变量tmp，并且初始化66

第二条代码：创建一个int型指针age，指向tmp变量，age中的值就是tmp的地址，==const具有左结合性，所以const修饰的是age，即指针的指向不变，始终指向tmp的地址==

第三条代码：创建一个int型变量newage，并且初始化23



第一条语句：*age=newage; 表示改变age指向地址中的值为23（星号为取地址符），但是指针的指向不变

第二条语句：age = &newage; 表示改变age的指向，使age指向newage变量的地址，由于const修饰了age，也就是指针的指向，所以指向不可改变，==第二条指令错误！！！==



> 关于指针的要点分析：
>
> ```c
> int * p;
> ```
>
>  我们要明白定义一个指针变量时，`* 和 p`分别代表这什么
>
> `*`是取值运算符，所以`*p`代表指针指向的地址中的值；
>
> `p`代表指针指向的地址；
>
> `&p`代表指针的地址；
>
> `*&p`代表指针地址中的值，也就是指针指向的地址



## 8.28 野指针

下列代码的运行结果是什么：

```c
int *p;
int a = 8;
*p = a;
printf("%d",*p);
```

运行结果如下：

<img src="../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/1598577426706.png" alt="1598577426706" style="zoom:200%;" />

> 错误提示：Segmentation fault ( core dumped )多为内存操作不当造成的，比如空指针、野指针的读写操作，数组的越界访问，破坏常量等。避免这个问题的最好方法就是在指针声明后对其进行初始化NULL操作。



分析：

虽然声明了p指针，但是没有说明p指向哪个内存位置，所以p就是一个野指针，对野指针执行`*p=a`后就会报错。

野指针形成的三种原因：

1.指针变量没有初始化，所有==指针在创建的时候不会被自动初始化为NULL的，缺省值是随机指向的==；

2.当指针==被free或者delete之后，没有指向NULL==，会不小心再次使用；

3.指针的操作超过了指针的作用范围，比如==不要返回指向栈内存的指针，因为在函数结束时栈内存会被释放==。



解决方法：

可以在声明指针的时候就指明地址：

```c
int a = 9;
int *p=&a;//初始化的时候就指向a变量的地址
printf("%d\n",*p);
```



## 8.29 输出源文件与当前执行的行数

问题：

如何输出源文件和当前执行的行数？写一个程序来实现。

分析：

<img src="../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/1598680892525.png" alt="1598680892525" style="zoom:200%;" />

要注意的是，宏定义左右都是==双下划线！！！==



代码如下：

```c
#include "stdio.h"

 int main( void )
 {
     int k;
     printf("Source file is %s\n",__FILE__);
     printf("Line number is %d\n",__LINE__);
     printf("Date is %s\n",__DATE__);
     printf("Time is %s\n",__TIME__);
     return 0;
 }
```

运行结果如下：

<img src="../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/1598681678483.png" alt="1598681678483" style="zoom:200%;" />



## 8.30 关系操作符

分析下面代码，求运行结果：

```c
int a = 20;

if( 1<=a<=10 ){
	printf("In range");
}
else{
	printf("Out of range");
}
```

主要考察的是`if( 1<=a<=10 )`的判断结果，由于是判断语句，所以结果就是真或者假，也就是1、0。

<=、>=是双目运算符，而且两者优先级相同，所以从左边开始结合，即先判断`1<=a`为真，也就是为1，接下来判断`1<=10`也自然为真，输出In range。



## 8.31 形参实参交换数据

判断下列程序的输出：

```c
void swap( int c, int d ){
    int t;
    t = c;
    c = d;
    d = t;
}

int main( void ){
    int a=2, b=3;
    swap( a, b );
    printf("%d,%d",a,b);
}
```

输出：2，3

这里涉及到形参与实参的区别，形参与实参的区别如下：
1.形参只在函数被调用的时候才会分配内存，调用结束后，一般情况释放内存，所以形参只在函数内部有效。

2.形参和实参必须在数量、位置、类型上一致。

3.函数调用中数据的传递方向是单向的，只能把实参的值传给形参，也就是一旦完成参数的传输，形参和实参就再也没有瓜葛了。

所以，对于这道题，swap( a, b )只是将a、b的值传给形参，在swap函数中，交换的是形参，与a、b没有关系，所以实际上a、b变量并没有完成交换。

如果要完成交换，可以将地址传进去，如下：

```c
void swap( int* c, int* d ){
    int t;
    t = *c;
    *c = *d;
    *d = t;
}

int main( void ){
    int a=2, b=3;
    swap( &a, &b );
    printf("%d,%d\n",a,b);
}
```

运行如下：
<img src="../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/1598839162176.png" alt="1598839162176" style="zoom:200%;" />



# 九月



## 9.1 数据类型转换

数据类型转换就是将数据从一种类型转换为另一种类型，数据可以是变量、数值、表达式等，数据类型的转换可以分为自动类型转换和强制类型转换。

> C语言中常量的默情况：整形默认为有符号int；浮点型默认为double;如果整形常量大小超出int，默认自然就为long int；如果需要无符号整形常量的话就可以在常量后面加u或是U，如0u或是0U，同理可以在常量后面加ul或UL表示无符号长整形常量；而浮点型常量后缀只有f或F，l或L，没有u或U，因为浮点数一般都为有符号 。
>
> L表示长整型、U表示无符号、F表示符点



**自动类型转换：**

自动类型转换就是编译器默认进行的类型转换，进行自动类型转换的情况一般如下：

1.当将一种类型的数据赋值给另一种类型的变量时，就会自动发送转换，赋值的时候会把右边的数据类型转换成左边的数据类型，但是这样可能导致数据失真或者精度降低，所以自动类型转换不一定是安全的。

```c
float f = 100;
int   k = f;
```

就像这样，先把100转换为float类型，然后赋值给f；再把f转换为int类型，赋值给k。

2.在不同数据类型的混合运算中，编译器也会自动转换数据类型，通常是将参与运算的数据先转换为同一种类型，然后进行运算，进行转换的规则如下：

* 按照数据长度增加的方向进行，以确保不丢失数据，比如int和long int参与的运算，会先把数据都转换为long int 类型的数据，然后进行运算。
* 所有的浮点运算都是按照双精度(double)进行的，即使运算中有float类型数据也要先转换为double，因为浮点数的默认类型是double。
* 在char与short 参与运算时，先要转换为int类型。

转换的图如下：
<img src="../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/1598953660406.png" alt="1598953660406" style="zoom:150%;" />

**强制类型转换：**
强制类型转换就是在写代码的时候强制转化数据类型的，强制转换的格式为：

```c
(type_name) expression
```

`type_name`为新类型名称，为表达式。例如：

```c
(float) a;  //将变量 a 转换为 float 类型
(int)(x+y);  //把表达式 x+y 的结果转换为 int 整型
(float) 100;  //将数值 100（默认为int类型）转换为 float 类型
```

下面是一个需要强制类型转换的经典例子：

```c
#include <stdio.h>
int main(){    
    int sum = 103;  //总数    
    int count = 7;  //数目    
    double average;  //平均数    
    average = (double) sum / count;    
    printf("Average is %lf!\n", average);    
    return 0;
}
```

运行结果：

Average is 14.714286!
sum 和 count 都是 int 类型，如果不进行干预，那么的运算结果也是 int 类型，小数部分将被丢弃；虽然是 average 是 double 类型，可以接收小数部分，但是心有余力不足，小数部分提前就被“阉割”了，它只能接收到整数部分，这就导致除法运算的结果严重失真。
`sum / count`
在这段代码中，有两点需要注意：

* ==对于除法运算，如果除数和被除数都是整数，那么运算结果也是整数，小数部分将被直接丢弃；如果除数和被除数其中有一个是小数，那么运算结果也是小数。==
* ==`( )`的优先级高于`/`，对于表达式`(double) sum / count`，会先执行`(double) sum`，将 sum 转换为 double 类型，然后再进行除法运算，这样运算结果也是 double 类型，能够保留小数部分。注意不要写作`(double) (sum / count)`，这样写运算结果将是 3.000000，仍然不能保留小数部分。==

**类型转换只是临时性的**

无论是自动类型转换还是强制类型转换，都只是为了本次运算而进行的临时性转换，转换的结果也会保存到临时的内存空间，不会改变数据本来的类型或者值。请看下面的例子：

```c
#include <stdio.h>
int main(){    
    double total = 400.8;  //总价    
    int count = 5;  //数目    
    double unit;  //单价    
    int total_int = (int)total;    
    unit = total / count;    
    printf("total=%lf, total_int=%d, unit=%lf\n", total, total_int, unit);    
    return 0;
}
```

运行结果：

注意看第 6 行代码，total 变量被转换成了 int 类型才赋值给 total_int 变量，而这种转换并未影响 total 变量本身的类型和值。如果 total 的值变了，那么 total 的输出结果将变为 400.000000；如果 total 的类型变了，那么 unit 的输出结果将变为 80.000000。在C语言中，有些类型既可以自动转换，也可以强制转换，例如 int 到 double，float 到 int 等；而有些类型只能强制转换，不能自动转换，例如以后将要学到的 void * 到 int *，int 到 char * 等。

可以自动进行的类型转换一般风险较低，不会对程序带来严重的后果，例如，int 到 double 没有什么缺点，float 到 int 顶多是数值失真。只能强制进行的类型转换一般风险较高，或者行为匪夷所思，例如，char * 到 int * 就是很奇怪的一种转换，这会导致取得的值也很奇怪，再如，int 到 char * 就是风险极高的一种转换，一般会导致程序崩溃。



## 9.2 指向数组的指针

判断下列程序的输出：

```c
int main( void ){
    int a[5]={1,2,3,4,5};
    int *p=( int* )( &a+1 );
    printf( "%d,%d", *(a+1), *(p-1) );
}
```

结果输出：

2,5



首先，指针的声明格式如示：类型 * [类型限定符列表] 名称 [= 初始化器];

```c
int *a;
int k = 5;
a = &k;
```

第一行中声明了一个指向int类型的指针a；第二行中声明了一个int型变量k；第三行中将指针a指向变量k；

或者也可以在声明指针的时候就将对象的值赋值给指针：

```
int k=5, *a=&k;
```

需要注意的是，==虽然指针指向的变量可能是不同类型的，但是在内存中指针的空间大小都是一样的==，比如32位计算机中指针的大小通常是4Byte（32bit）。



然后，指针变量的加减运算与其数据类型有关（数据类型大小以字节为单位），比如上面的a++；k的地址就会加4，因为k是int，一般占4Byte。就像数组中一样，元素都是顺序排列的，+1就指向下一个元素。



在定义数组的时候，需要给出数组名和数组长度，数组名可以认为是被转换为了一个指针，指向数组的首个元素。但是！！！==数组名的本意表示的是整个数组，也就是表示数组所有元素的集合，在使用过程中经常会转换为指向第0个元素的指针，实际上数组名和数组首地址并不是等价的。==在绝大多数表达式中，数组名代表指向第0个元素的指针，有两种情况例外：

* sizeof返回整个数组所占用的字节，而不是数组第0个元素占用的字节
* ==单目操作符&作用于数组名时，返回一个指向数组的指针，而不是一个指向数组第0个元素的指针==



所以在这里：

```c
int *p = (int*)( &a+1 );
```

首先执行&a，==得到一个指向数组a整体的指针，然后&a+1代表在数组整体的基础上地址加一（这里的加一表示的是下一个元素的地址，并不是实际内存+1Byte，反而是实际内存+4Byte，在32位情况下），所以&a+1在逻辑上相当于a[5]，然后再通过( int* )强制转换为int类型指针，使p指针指向a[5]的地址（逻辑上）。==

所以在后面*(p-1)中，p相当于&a[5]，所以可以看作a[5-1]，即a[4]，答案为5





## 9.3 指针加法

运行这段程序：

```c
int main( void ){
    int *p=0;
    p++;
    printf("p=%d\n",p);
    return 0;
}
```

`int *p=0;`是定义了一个指向0地址的int型指针

`p++`代表指针指向下一个int型地址

int型数据占4Byte，所以下一个int型地址就是在上一个int地址的基础上＋4

所以此时p指向的地址就是0+4

即打印出p=4

> 注意：指针的大小是1Byte，指针指向的地址是根据数据类型有所不同的





## 9.4 预处理器（Preprocessor）

题目：

 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题 )?

分析：

一年有多少秒，365X24X60X60=31,536,000，但是如果运行的CPU是16位，16位无符号数的范围是0~65535，就会造成整型数据溢出，所以要将此数据声明为无符号长整型数据，即：

```c
#define YEAR_TIME (365*24*60*60)UL
```

加上UL声明为无符号整型数据！



## 9.5 数组作为参数的sizeof

题目：

在 32位系统下，执行如下代码，运算结果是多少？

```c
void func( char str[100]){
   printf("%d",sizeof( str ) );
}

int main(void){
    char str[] = "www.firebbs.cn";
    char *p = str ;
    int n = 10;
    printf("%d,%d,%d,",sizeof (str ),sizeof ( p ) ,sizeof ( n ) );
    func(str);
    return 0;
}
```

我都输出：

14，4，4，100

实际答案：

15，4，4，4



分析：

* `char str[] = "www.firebbs.cn";`注意str是一个数组，而且声明的时候是一个字符串，所以字符串最后还有一个结束符’\0’，所以sizeof(str)=14+1=15

* `char *p = str ;`，p只是一个指向str首地址的指针，所有指针的大小都是32bit（32位系统下），所以sizeof(p)=4

* `int n = 10;`，32位系统下的int一般为四个字节，即sizeof(n)=4

* ```c
  void func( char str[100]){
     printf("%d",sizeof( str ) );
  }
  ```

  传入函数之后，会把str当作指针处理，不会在栈里开辟100Byte的空间的，所以这里的str相当于一个char型的指针，32位下所有指针大小都是4Byte，所以sizeof(str)=4

==数组作为参数传入函数后，按照指针处理==



## 9.6 可变参数入栈的顺序

题目：

运行下列代码，求输出？

```c
int a=0, b=0;
printf("%d,%d,%d",a++,++b,a+b);
```

我的答案：

0，1，1

实际答案：
0，1，0

分析：
考察的是可变参数的入栈顺序，==可变参数的入栈顺序都是从右往左==。

所以先执行a+b，此时a=b=0，所以a+b=0

然后向左走，++b，先自增，再赋值，b=1

然后向左走，a++，先赋值，再自增，所以格式化输出的时候a=0，运行完代码之后a=1

> 注意：这里的可变参数针对的是所有的含可变参数的函数，其入栈顺序都是从右往左；赋值说的是向格式化输出的那个位置赋值，也就是%d所在的位置赋值。；==自然而然出栈顺序就是从左往右。== 参数入栈顺序是和具体编译器实现相关的。比如，Pascal语言中参数就是从左到右入栈的，有些语言中还可以通过修饰符进行指定，如Visual C++。 



[参考链接](https://blog.csdn.net/u014181676/article/details/22103265?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf)





## 9.7 逗号表达式的应用

题目：

运行如下代码，求b的结果是多少？

```c
int a,b;
a = b = 1;
b = a++, b++, ++a;
```

我的答案：

b=2

正确答案：

b=2

分析：
这里涉及到逗号运算符，逗号运算符的优先级是最低的， 逗号表达式的运算过程为：从左往右逐个计算表达式 。逗号运算符最为一个整体，最后的结果就是最右边的表达式。

在这里：`b = a++, b++, ++a;`依次从左往右执行各个表达式，先a++，是整行代码执行完毕之后才+1；然后是b++，也是整行代码执行完毕之后才+1；最后是++a，即a=a+1=2；逗号表达式的值就是最后一个表达式的值，即2.



再比如这段程序：

```c
char a = 8;
printf("%d",(a=3*5,a*4));
```

输出的是60

分析：逗号运算符，先执行表达式a=3*5，执行完毕a=15，然后执行下一个表达式`a *4`，得出15 *4=60。逗号表达式的值是最后一个表达式的运算结果，所以结果就是60.



## 9.8 有符号和无符号的大小比较

分析下列代码运行结果：

```c
int main( void ){
    int a = -1;
    unsigned int b = 1;
    if( a > b ){
        printf("1\n");
    }else{
        printf("0\n");
    }
    return 0;
}
```

我的答案：

0

正确答案：
1

分析：

==有符号和无符号的数值进行比较的时候，编译器会将有符号参数类型的转换为无符号数==的来进行比较

所以

a = 0Xffffffff

b = 0X00000001

则-1L   > 1UL，输出1。

如何正确表达有符号和无符号的大小？

在有符号前加上强制转换类型，比如`if( a > (int)b )`就可以正确判断了

平时==尽量避免使用unsigned与有符号的数据类型比较大小==。



注意：

* 1.在位运算、模运算、回绕溢出利用较多的算法实现中（比如各种加密学算法、编码、压缩算法等）

有符号数的符号位在进行位运算时候会造成一些迷惑，位运算中如果采用无符号数会大大减少处理问题时对语言上的思考，可以更专心关注实际问题。

*  2.在网络收发，串口读写时候使用无符号数

TCP/IP 经常遇到无符号数，比如IP的表示，我们可以用 ip2long 把点分十进制 ip 转成一个 unsigned int 来表示，这会带来很大方便。串口读写的流更多的是用 unsigned char ，最常见的一个问题是 unsigned char 可以避免日志输出时候按照有符号输出造成的 ‘0xff’ 迷惑人的前缀。

* 3.避免有符号数与无符号数的直接接触，包括比较，运算

无符号数与有符号数比较时，编译器会发出警告。同时编译器内部也存在一套默认的类型转换规则（编译器自动进行，用户无感知）。大致分为3类（如有错误请指正）（说明：在计算机里，负数使用反码表示的）

　　先顶一下规则：有符号（int），无符号（unsigned int），非无符号（除 int 与 unsigned int外的类型，如char，unsigned char），非有符号（与前面同理）。

　　有符号与无符号比较：有符号数会转换成无符号数来进行比较（如int 与 unsigned int 比较，int 转换成 unsigned int）。

　　有符号与非无符号数比较：非无符号转化成有符号（如int 与 unsigned char比较，unsigned char 转换成 int）。

　　无符号与非有符号数比较：非有符号转化成有符号（如unsigned int 与 char比较，char 转换成 unsigned int）。

* 4.不要只因为某个数不可能为负就用无符号数

因为这虽然看起来很合要求，但是当无符号溢出时候带来的问题却很可能致命。

[详细说明链接](https://blog.csdn.net/u010765526/article/details/73613815)

[不错的文章](https://www.cnblogs.com/sinpo828/p/10943157.html)



## 9.9 位域的占用空间

题目如下，求输出结果：

```c
struct test{
    char  a:3;
    short b:4;
    char  c:5;
};
printf("%d",sizeof(test));
```

答案是：2

分析：

这里涉及到位域，在定义结构体的时候，我们可以指定成员变量所占用的位数，这就是位域，一种数据结构。位域的产生是由于有些数据在存储的时候并不需要占用一个完整的字节，可能几个位就可以满足需求。

在成员变量后面加上:x来表示位域为x，有关位域我们作如下几点说明：

* 位域的宽度不可以超过成员变量的最大长度
* 只有int、signed int、unsigned int、_Bool这几种数据类型是被C99支持的，但是编译器在实现的时候扩展了char、signed char、unsigned char、enum这几种数据类型。
* 当相邻的成员类型相同时，而且成员的==位宽之和小于sizeof(数据类型)，成员是按照位宽挨着存储的==，直到；如果==位宽之和大于sizeof(数据类型)，超出的成员将从新的存储单元开始==，整体偏移量为该数据类型的整数倍，同时对于整个结构体还要考虑内存对齐。
* 当相邻的成员==类型不相同==时，不同的编译器有不同的实现。在==GCC中，会压缩存储。VC和VS则不会压缩==，是按照结构体内存对齐进行存储的。
* 如果成员之间穿插着==非位域成员，则不会进行压缩==。
*  位域成员往往不占用完整的字节，有时候也不处于字节的开头位置，因此使用`&`获取位域成员的地址是没有意义的，C语言也禁止这样做。地址是字节（Byte）的编号，而不是位（Bit）的编号。 

所以对于这道题，a占用了3bit，下一个成员和a类型不同，在GCC下是可以压缩的，占用4bit，再下一个占用5bit，一共占用12bit。内存对齐，就是2Byte。



[参考文章](http://c.biancheng.net/view/2037.html)



## 9.10 移位 异或 优先级

分析下列程序的结果：

```c
int a=6,b=4;
a^b<<2=?
```

求`a^b<<2`的值？

我的答案：8

正确答案：22

分析：
我开始以为^的优先级比<<的优先级高，所以先进行异或运算，然后进行移位，得到8。实际上<<的优先级要比^的优先级高，所以先进行移位运算，b<<2得到16，6^16得到22.

应该是`a^( b<<2 )`。



## 9.11 结构体元素偏移

```c
//int 占 2 个字节，char 占 1 个字节，float 占 4 个字节
struct stu{
    union{
        char bj[5];
        int  bn[2];
    }class;//5
    char  xm[8];//8
    float cj;//4
}xc;
```

问题：求sizeof(xc)?

我的答案：32

正确答案：20

分析：

无论结构体还是联合体，都讲究一个字节对齐，==按照其内部最大元素内存大小对齐！！！==

所以union中最大元素类型是int，这里是2字节，所以==union按照2字节对齐==，char bj[5]占了5字节，按照2字节对齐的时候再补一个字节，所以==union的大小是6Byte==；在struct中，class已经占了前6字节，==char xm[8]中每一个char占1字节，所以char数组可以紧接着存放8个字节==，现在内存大小为6+8=14字节，由于==float需要4字节对齐，所以float从第16字节开始存储，占用4字节==。至此struct内存大小占用20字节！

> 注意:结构体涉及数组的时候，我觉得可以把数组拆分开看作一个个元素，就好多了，只出现数组是不可以按照数组整体来内存对齐的.

结构体定义如下：

```c
//int 占 2 个字节，char 占 1 个字节，float 占 4 个字节
struct stu{
    union{
        char bj[5];
        int  bn[2];
    }class;//5
    char  xm[8];//8
    float cj;//4
}xc;
```

问题：若xc地址为0X1000，求&xm[0]的值？

我的答案：0X1006

根据上面的内容，union大小为6Byte，所以相对于结构体的偏移地址是6，则紧挨着的xm[0]的地址就是0X1000+6=0X1006



> 为了提高 CPU 的存储速度，编译器会对一些变量的起始地址做了“对齐”处理。
> 对齐方式（变量存放的起始地址相对于结构的起始地址的偏移量） 
> char    偏移量必须为 sizeof(char)  即 1 的倍数 
> int      偏移量必须为 sizeof(int)   即 4 的倍数  (跟编译器有关，有可能是 2)
> float  偏移量必须为 sizeof(float) 即 4 的倍数 
> double  偏移量必须为 sizeof(double) 即 8 的倍数 
> short  偏移量必须为 sizeof(short) 即 2 的倍数 





## 9.12 指针、数组的声明

题目：

用变量a给出下面的定义 

1、一个整型数（An integer）

 2、一个指向整型数的指针（ A pointer to an integer）

3、一个指向指针的的指针，它指向的指针是指向一个整数（ A pointer to a pointer to an intege）

4、一个有10个整型数的数组（ An array of 10 integers）

5、一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers）

 6、 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers）

 7、 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer） 

8、一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer 

答案：
1：`int a`

2：`int *a`

3：`int **a`

4：`int a[10]`

5：`int* a[10]`

6：`int (*a)[10]`

7：`int (*a)(int)`

8：`int (*a[10])(int)`

`[]`的优先级比`*`要高，所以可以根据题中的要求来判断`[]`和`*`的先后执行顺序。

比如5题：一个10个指针的数组，指针指向整型数；首先是一个10个元素的数组，所以首先a[10]，然后指定数组元素是指针指向整型，所以声明元素为`int *`。

再比如6题：一个指针，指向有10个整型数的数组；首先是一个指针，所以先声明指针，即`*a`，然后指针的指向是一个10个元素的整型数组，所以就成了`int (*a)[10]`。

当涉及到函数的时候，分为三部分：函数返回值类型、指向函数的类型、函数的参数类型。指向函数的格式就是加上一个括号，代表函数体。

所以7题分析为：返回值和参数都是整型数，所以`int () (int)`确定了两部分，然后是指向函数的指针，所以就有了`int (*a)(int)`

同理8题：返回值和参数都是整型，指向函数的是一个10个元素数组，数组的元素指向函数，所以就有`int (*a[10])(int)`



## 9.13 负数的求余运算

运行下列语句，求出x的值：

```c
int x=10;
x += 3+x%(-3);//x=x+3+x%(-3)=13+
```

 答案：14

分析：

`x += 3+x%(-3)`中，`+=`运算比较好判断，主要是`x%(-3)`的判断不知道是1还是-1，==在求余运算中，余数的符号与被除数的符号相同==，所以在这里x=10，则得数就是1，即`x += 3+1`易得x的值为14.





















