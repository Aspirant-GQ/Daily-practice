
# 八月

## 8.23 resister关键字

当对一个变量频繁被读写时，需要反复访问内存，从而花费大量的存取时间。为此，C语言提供了一种变量，即寄存器变量。这种变量存放在CPU的寄存器中，使用时，不需要访问内存，而直接从寄存器中读写，从而提高效率。寄存器变量的说明符是register。对于循环次数较多的循环控制变量及循环体内反复使用的变量均可定义为寄存器变量，而循环计数是应用寄存器变量的最好候选者。



(1) 只有局部自动变量和形参才可以定义为寄存器变量。因为寄存器变量属于动态存储方式，凡需要采用静态存储方式的量都不能定义为寄存器变量，包括：模块间全局变量、模块内全局变量、局部static变量;



(2) register是一个"建议"型关键字，意指程序建议该变量放在寄存器中，但最终该变量可能因为条件不满足并未成为寄存器变量，而是被放在了存储器中，但编译器中并不报错(在C++语言中有另一个"建议"型关键字：inline)。





## 8.24 数组的[]原理

分析下列代码的输出结果：

```c
int array[10]={0};
0[array] = 1;
printf("%d",(-5)[array+5]);
```

结果是输出：1

因为==array[2]可以看作`*(array+2)`==，所以`(-5)[array+5]`就相当于`*(-5+array+5)`，也就是`*(array+0)`。

所以，尽量使用指针代替数组， ==指针方法的优点是，array的地址每次装入地址p后，在每次循环中只需对p增量操作。在数组索引方法中，每次循环中都必须进行基于t值求数组下标的复杂运算 。==





##  8.25 static作用

Static是C的一个关键字，根据其修饰的对象属性不同可以分为两种用途：

1.修饰存储类型，使之成为静态存储类型

2.修饰链接属性，使之成为内部链接属性

==静态存储类型：==

当修饰在函数内部定义的局部变量时，这个局部变量就存储在函数的内存静态区，函数运行结束后也不会销毁这个局部变量的值，**函数下次运行的时候依然可以使用上次运行后的变量的值**。

当修饰全局变量的时候，此时的全局变量就是静态全局变量，**该变量的作用域只能够限制在定义该变量的文件中，而且其他文件不能够通过extern关键字来引用**。



==内部链接属性：==

 静态函数只能在声明它的源文件中使用 。



例子：




## 8.26 字符串结束问题

判断如下程序输出的值：

```c
char c[][8]={"apple","orange","banana"};
  
printf("%d,",sizeof(c));
printf("%d",strlen(c));
```

这涉及到sizeof和strlen的区别：

* sizeof是判断类型占用的大小，取决于数据类型
* strlen是判断字符串长度的，遇到字符串结束符‘\0’的时候就结束了，所以结果取决于‘\0’的位置



所以对于

```c
char c[][8]={"apple","orange","banana"};
```

三个元素，每个元素的空间是8个字节，所以sizeof(c)输出的是8*3=24

然鹅，对于strlen，在第一个字符串元素“apple”的末尾就遇到了‘\0’，所以在第一个字符串元素结束后就会结束判断，所以最终结果是apple这五个字符的长度，即5

图示：
![1598450805538](../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/1598450805538.png)





## 8.27 const用法

const具有左结合性，即通常：const + 修饰变量



对于const的用法，程序如下：

```c
int tmp = 66;
int *const age = &tmp;
int newage = 23;
```

执行的语句如下：

```c
*age=newage;
age = &newage;
```

问题：判断哪个语句是正确的，为什么？

分析：

第一条代码：创建一个int型变量tmp，并且初始化66

第二条代码：创建一个int型指针age，指向tmp变量，age中的值就是tmp的地址，==const具有左结合性，所以const修饰的是age，即指针的指向不变，始终指向tmp的地址==

第三条代码：创建一个int型变量newage，并且初始化23



第一条语句：*age=newage; 表示改变age指向地址中的值为23（星号为取地址符），但是指针的指向不变

第二条语句：age = &newage; 表示改变age的指向，使age指向newage变量的地址，由于const修饰了age，也就是指针的指向，所以指向不可改变，==第二条指令错误！！！==



> 关于指针的要点分析：
>
> ```c
> int * p;
> ```
>
> 我们要明白定义一个指针变量时，`* 和 p`分别代表这什么
>
> `*`是取值运算符，所以`*p`代表指针指向的地址中的值；
>
> `p`代表指针指向的地址；
>
> `&p`代表指针的地址；
>
> `*&p`代表指针地址中的值，也就是指针指向的地址



## 8.28 野指针

下列代码的运行结果是什么：

```c
int *p;
int a = 8;
*p = a;
printf("%d",*p);
```

运行结果如下：

<img src="../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/1598577426706.png" alt="1598577426706" style="zoom:200%;" />

> 错误提示：Segmentation fault ( core dumped )多为内存操作不当造成的，比如空指针、野指针的读写操作，数组的越界访问，破坏常量等。避免这个问题的最好方法就是在指针声明后对其进行初始化NULL操作。



分析：

虽然声明了p指针，但是没有说明p指向哪个内存位置，所以p就是一个野指针，对野指针执行`*p=a`后就会报错。

野指针形成的三种原因：

1.指针变量没有初始化，所有==指针在创建的时候不会被自动初始化为NULL的，缺省值是随机指向的==；

2.当指针==被free或者delete之后，没有指向NULL==，会不小心再次使用；

3.指针的操作超过了指针的作用范围，比如==不要返回指向栈内存的指针，因为在函数结束时栈内存会被释放==。



解决方法：

可以在声明指针的时候就指明地址：

```c
int a = 9;
int *p=&a;//初始化的时候就指向a变量的地址
printf("%d\n",*p);
```



## 8.29 输出源文件与当前执行的行数

问题：

如何输出源文件和当前执行的行数？写一个程序来实现。

分析：

<img src="../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/1598680892525.png" alt="1598680892525" style="zoom:200%;" />

要注意的是，宏定义左右都是==双下划线！！！==



代码如下：

```c
#include "stdio.h"

 int main( void )
 {
     int k;
     printf("Source file is %s\n",__FILE__);
     printf("Line number is %d\n",__LINE__);
     printf("Date is %s\n",__DATE__);
     printf("Time is %s\n",__TIME__);
     return 0;
 }

```

运行结果如下：

<img src="../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/1598681678483.png" alt="1598681678483" style="zoom:200%;" />



## 8.30 关系操作符

分析下面代码，求运行结果：

```c
int a = 20;

if( 1<=a<=10 ){
	printf("In range");
}
else{
	printf("Out of range");
}

```

主要考察的是`if( 1<=a<=10 )`的判断结果，由于是判断语句，所以结果就是真或者假，也就是1、0。

<=、>=是双目运算符，而且两者优先级相同，所以从左边开始结合，即先判断`1<=a`为真，也就是为1，接下来判断`1<=10`也自然为真，输出In range。



## 8.31 形参实参交换数据

判断下列程序的输出：

```c
void swap( int c, int d ){
    int t;
    t = c;
    c = d;
    d = t;
}

int main( void ){
    int a=2, b=3;
    swap( a, b );
    printf("%d,%d",a,b);
}

```

输出：2，3

这里涉及到形参与实参的区别，形参与实参的区别如下：
1.形参只在函数被调用的时候才会分配内存，调用结束后，一般情况释放内存，所以形参只在函数内部有效。

2.形参和实参必须在数量、位置、类型上一致。

3.函数调用中数据的传递方向是单向的，只能把实参的值传给形参，也就是一旦完成参数的传输，形参和实参就再也没有瓜葛了。

所以，对于这道题，swap( a, b )只是将a、b的值传给形参，在swap函数中，交换的是形参，与a、b没有关系，所以实际上a、b变量并没有完成交换。

如果要完成交换，可以将地址传进去，如下：

```c
void swap( int* c, int* d ){
    int t;
    t = *c;
    *c = *d;
    *d = t;
}

int main( void ){
    int a=2, b=3;
    swap( &a, &b );
    printf("%d,%d\n",a,b);
}

```

运行如下：
<img src="../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/1598839162176.png" alt="1598839162176" style="zoom:200%;" />



# 九月



## 9.1 数据类型转换

数据类型转换就是将数据从一种类型转换为另一种类型，数据可以是变量、数值、表达式等，数据类型的转换可以分为自动类型转换和强制类型转换。

> C语言中常量的默情况：整形默认为有符号int；浮点型默认为double;如果整形常量大小超出int，默认自然就为long int；如果需要无符号整形常量的话就可以在常量后面加u或是U，如0u或是0U，同理可以在常量后面加ul或UL表示无符号长整形常量；而浮点型常量后缀只有f或F，l或L，没有u或U，因为浮点数一般都为有符号 。
>
> L表示长整型、U表示无符号、F表示符点



**自动类型转换：**

自动类型转换就是编译器默认进行的类型转换，进行自动类型转换的情况一般如下：

1.当将一种类型的数据赋值给另一种类型的变量时，就会自动发送转换，赋值的时候会把右边的数据类型转换成左边的数据类型，但是这样可能导致数据失真或者精度降低，所以自动类型转换不一定是安全的。

```c
float f = 100;
int   k = f;

```

就像这样，先把100转换为float类型，然后赋值给f；再把f转换为int类型，赋值给k。

2.在不同数据类型的混合运算中，编译器也会自动转换数据类型，通常是将参与运算的数据先转换为同一种类型，然后进行运算，进行转换的规则如下：

* 按照数据长度增加的方向进行，以确保不丢失数据，比如int和long int参与的运算，会先把数据都转换为long int 类型的数据，然后进行运算。
* 所有的浮点运算都是按照双精度(double)进行的，即使运算中有float类型数据也要先转换为double，因为浮点数的默认类型是double。
* 在char与short 参与运算时，先要转换为int类型。

转换的图如下：
<img src="../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/1598953660406.png" alt="1598953660406" style="zoom:150%;" />

**强制类型转换：**
强制类型转换就是在写代码的时候强制转化数据类型的，强制转换的格式为：

```c
(type_name) expression

```

`type_name`为新类型名称，为表达式。例如：

```c
(float) a;  //将变量 a 转换为 float 类型
(int)(x+y);  //把表达式 x+y 的结果转换为 int 整型
(float) 100;  //将数值 100（默认为int类型）转换为 float 类型

```

下面是一个需要强制类型转换的经典例子：

```c
#include <stdio.h>
int main(){    
    int sum = 103;  //总数    
    int count = 7;  //数目    
    double average;  //平均数    
    average = (double) sum / count;    
    printf("Average is %lf!\n", average);    
    return 0;
}

```

运行结果：

Average is 14.714286!
sum 和 count 都是 int 类型，如果不进行干预，那么的运算结果也是 int 类型，小数部分将被丢弃；虽然是 average 是 double 类型，可以接收小数部分，但是心有余力不足，小数部分提前就被“阉割”了，它只能接收到整数部分，这就导致除法运算的结果严重失真。
`sum / count`
在这段代码中，有两点需要注意：

* ==对于除法运算，如果除数和被除数都是整数，那么运算结果也是整数，小数部分将被直接丢弃；如果除数和被除数其中有一个是小数，那么运算结果也是小数。==
* ==`( )`的优先级高于`/`，对于表达式`(double) sum / count`，会先执行`(double) sum`，将 sum 转换为 double 类型，然后再进行除法运算，这样运算结果也是 double 类型，能够保留小数部分。注意不要写作`(double) (sum / count)`，这样写运算结果将是 3.000000，仍然不能保留小数部分。==

**类型转换只是临时性的**

无论是自动类型转换还是强制类型转换，都只是为了本次运算而进行的临时性转换，转换的结果也会保存到临时的内存空间，不会改变数据本来的类型或者值。请看下面的例子：

```c
#include <stdio.h>
int main(){    
    double total = 400.8;  //总价    
    int count = 5;  //数目    
    double unit;  //单价    
    int total_int = (int)total;    
    unit = total / count;    
    printf("total=%lf, total_int=%d, unit=%lf\n", total, total_int, unit);    
    return 0;
}

```

运行结果：

注意看第 6 行代码，total 变量被转换成了 int 类型才赋值给 total_int 变量，而这种转换并未影响 total 变量本身的类型和值。如果 total 的值变了，那么 total 的输出结果将变为 400.000000；如果 total 的类型变了，那么 unit 的输出结果将变为 80.000000。在C语言中，有些类型既可以自动转换，也可以强制转换，例如 int 到 double，float 到 int 等；而有些类型只能强制转换，不能自动转换，例如以后将要学到的 void * 到 int *，int 到 char * 等。

可以自动进行的类型转换一般风险较低，不会对程序带来严重的后果，例如，int 到 double 没有什么缺点，float 到 int 顶多是数值失真。只能强制进行的类型转换一般风险较高，或者行为匪夷所思，例如，char * 到 int * 就是很奇怪的一种转换，这会导致取得的值也很奇怪，再如，int 到 char * 就是风险极高的一种转换，一般会导致程序崩溃。



## 9.2 指向数组的指针

判断下列程序的输出：

```c
int main( void ){
    int a[5]={1,2,3,4,5};
    int *p=( int* )( &a+1 );
    printf( "%d,%d", *(a+1), *(p-1) );
}

```

结果输出：

2,5



首先，指针的声明格式如示：类型 * [类型限定符列表] 名称 [= 初始化器];

```c
int *a;
int k = 5;
a = &k;

```

第一行中声明了一个指向int类型的指针a；第二行中声明了一个int型变量k；第三行中将指针a指向变量k；

或者也可以在声明指针的时候就将对象的值赋值给指针：

```
int k=5, *a=&k;

```

需要注意的是，==虽然指针指向的变量可能是不同类型的，但是在内存中指针的空间大小都是一样的==，比如32位计算机中指针的大小通常是4Byte（32bit）。



然后，指针变量的加减运算与其数据类型有关（数据类型大小以字节为单位），比如上面的a++；k的地址就会加4，因为k是int，一般占4Byte。就像数组中一样，元素都是顺序排列的，+1就指向下一个元素。



在定义数组的时候，需要给出数组名和数组长度，数组名可以认为是被转换为了一个指针，指向数组的首个元素。但是！！！==数组名的本意表示的是整个数组，也就是表示数组所有元素的集合，在使用过程中经常会转换为指向第0个元素的指针，实际上数组名和数组首地址并不是等价的。==在绝大多数表达式中，数组名代表指向第0个元素的指针，有两种情况例外：

* sizeof返回整个数组所占用的字节，而不是数组第0个元素占用的字节
* ==单目操作符&作用于数组名时，返回一个指向数组的指针，而不是一个指向数组第0个元素的指针==



所以在这里：

```c
int *p = (int*)( &a+1 );

```

首先执行&a，==得到一个指向数组a整体的指针，然后&a+1代表在数组整体的基础上地址加一（这里的加一表示的是下一个元素的地址，并不是实际内存+1Byte，反而是实际内存+4Byte，在32位情况下），所以&a+1在逻辑上相当于a[5]，然后再通过( int* )强制转换为int类型指针，使p指针指向a[5]的地址（逻辑上）。==

所以在后面*(p-1)中，p相当于&a[5]，所以可以看作a[5-1]，即a[4]，答案为5





## 9.3 指针加法

运行这段程序：

```c
int main( void ){
    int *p=0;
    p++;
    printf("p=%d\n",p);
    return 0;
}

```

`int *p=0;`是定义了一个指向0地址的int型指针

`p++`代表指针指向下一个int型地址

int型数据占4Byte，所以下一个int型地址就是在上一个int地址的基础上＋4

所以此时p指向的地址就是0+4

即打印出p=4

> 注意：指针的大小是1Byte，指针指向的地址是根据数据类型有所不同的





## 9.4 预处理器（Preprocessor）

题目：

 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题 )?

分析：

一年有多少秒，365X24X60X60=31,536,000，但是如果运行的CPU是16位，16位无符号数的范围是0~65535，就会造成整型数据溢出，所以要将此数据声明为无符号长整型数据，即：

```c
#define YEAR_TIME (365*24*60*60)UL

```

加上UL声明为无符号整型数据！



## 9.5 数组作为参数的sizeof

题目：

在 32位系统下，执行如下代码，运算结果是多少？

```c
void func( char str[100]){
   printf("%d",sizeof( str ) );
}

int main(void){
    char str[] = "www.firebbs.cn";
    char *p = str ;
    int n = 10;
    printf("%d,%d,%d,",sizeof (str ),sizeof ( p ) ,sizeof ( n ) );
    func(str);
    return 0;
}

```

我都输出：

14，4，4，100

实际答案：

15，4，4，4



分析：

* `char str[] = "www.firebbs.cn";`注意str是一个数组，而且声明的时候是一个字符串，所以字符串最后还有一个结束符’\0’，所以sizeof(str)=14+1=15

* `char *p = str ;`，p只是一个指向str首地址的指针，所有指针的大小都是32bit（32位系统下），所以sizeof(p)=4

* `int n = 10;`，32位系统下的int一般为四个字节，即sizeof(n)=4

* ```c
  void func( char str[100]){
     printf("%d",sizeof( str ) );
  }
  
  ```

  传入函数之后，会把str当作指针处理，不会在栈里开辟100Byte的空间的，所以这里的str相当于一个char型的指针，32位下所有指针大小都是4Byte，所以sizeof(str)=4

==数组作为参数传入函数后，按照指针处理==



## 9.6 可变参数入栈的顺序

题目：

运行下列代码，求输出？

```c
int a=0, b=0;
printf("%d,%d,%d",a++,++b,a+b);

```

我的答案：

0，1，1

实际答案：
0，1，0

分析：
考察的是可变参数的入栈顺序，==可变参数的入栈顺序都是从右往左==。

所以先执行a+b，此时a=b=0，所以a+b=0

然后向左走，++b，先自增，再赋值，b=1

然后向左走，a++，先赋值，再自增，所以格式化输出的时候a=0，运行完代码之后a=1

> 注意：这里的可变参数针对的是所有的含可变参数的函数，其入栈顺序都是从右往左；赋值说的是向格式化输出的那个位置赋值，也就是%d所在的位置赋值。；==自然而然出栈顺序就是从左往右。== 参数入栈顺序是和具体编译器实现相关的。比如，Pascal语言中参数就是从左到右入栈的，有些语言中还可以通过修饰符进行指定，如Visual C++。 



[参考链接](https://blog.csdn.net/u014181676/article/details/22103265?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf)





## 9.7 逗号表达式的应用

题目：

运行如下代码，求b的结果是多少？

```c
int a,b;
a = b = 1;
b = a++, b++, ++a;

```

我的答案：

b=2

正确答案：

b=2

分析：
这里涉及到逗号运算符，逗号运算符的优先级是最低的， 逗号表达式的运算过程为：从左往右逐个计算表达式 。逗号运算符最为一个整体，最后的结果就是最右边的表达式。

在这里：`b = a++, b++, ++a;`依次从左往右执行各个表达式，先a++，是整行代码执行完毕之后才+1；然后是b++，也是整行代码执行完毕之后才+1；最后是++a，即a=a+1=2；逗号表达式的值就是最后一个表达式的值，即2.



再比如这段程序：

```c
char a = 8;
printf("%d",(a=3*5,a*4));

```

输出的是60

分析：逗号运算符，先执行表达式a=3*5，执行完毕a=15，然后执行下一个表达式`a *4`，得出15 *4=60。逗号表达式的值是最后一个表达式的运算结果，所以结果就是60.



## 9.8 有符号和无符号的大小比较

分析下列代码运行结果：

```c
int main( void ){
    int a = -1;
    unsigned int b = 1;
    if( a > b ){
        printf("1\n");
    }else{
        printf("0\n");
    }
    return 0;
}

```

我的答案：

0

正确答案：
1

分析：

==有符号和无符号的数值进行比较的时候，编译器会将有符号参数类型的转换为无符号数==的来进行比较

所以

a = 0Xffffffff

b = 0X00000001

则-1L   > 1UL，输出1。

如何正确表达有符号和无符号的大小？

在有符号前加上强制转换类型，比如`if( a > (int)b )`就可以正确判断了

平时==尽量避免使用unsigned与有符号的数据类型比较大小==。



注意：

* 1.在位运算、模运算、回绕溢出利用较多的算法实现中（比如各种加密学算法、编码、压缩算法等）

有符号数的符号位在进行位运算时候会造成一些迷惑，位运算中如果采用无符号数会大大减少处理问题时对语言上的思考，可以更专心关注实际问题。

*  2.在网络收发，串口读写时候使用无符号数

TCP/IP 经常遇到无符号数，比如IP的表示，我们可以用 ip2long 把点分十进制 ip 转成一个 unsigned int 来表示，这会带来很大方便。串口读写的流更多的是用 unsigned char ，最常见的一个问题是 unsigned char 可以避免日志输出时候按照有符号输出造成的 ‘0xff’ 迷惑人的前缀。

* 3.避免有符号数与无符号数的直接接触，包括比较，运算

无符号数与有符号数比较时，编译器会发出警告。同时编译器内部也存在一套默认的类型转换规则（编译器自动进行，用户无感知）。大致分为3类（如有错误请指正）（说明：在计算机里，负数使用反码表示的）

　　先顶一下规则：有符号（int），无符号（unsigned int），非无符号（除 int 与 unsigned int外的类型，如char，unsigned char），非有符号（与前面同理）。

　　有符号与无符号比较：有符号数会转换成无符号数来进行比较（如int 与 unsigned int 比较，int 转换成 unsigned int）。

　　有符号与非无符号数比较：非无符号转化成有符号（如int 与 unsigned char比较，unsigned char 转换成 int）。

　　无符号与非有符号数比较：非有符号转化成有符号（如unsigned int 与 char比较，char 转换成 unsigned int）。

* 4.不要只因为某个数不可能为负就用无符号数

因为这虽然看起来很合要求，但是当无符号溢出时候带来的问题却很可能致命。

[详细说明链接](https://blog.csdn.net/u010765526/article/details/73613815)

[不错的文章](https://www.cnblogs.com/sinpo828/p/10943157.html)



## 9.9 位域的占用空间

题目如下，求输出结果：

```c
struct test{
    char  a:3;
    short b:4;
    char  c:5;
};
printf("%d",sizeof(test));

```

答案是：2

分析：

这里涉及到位域，在定义结构体的时候，我们可以指定成员变量所占用的位数，这就是位域，一种数据结构。位域的产生是由于有些数据在存储的时候并不需要占用一个完整的字节，可能几个位就可以满足需求。

在成员变量后面加上:x来表示位域为x，有关位域我们作如下几点说明：

* 位域的宽度不可以超过成员变量的最大长度
* 只有int、signed int、unsigned int、_Bool这几种数据类型是被C99支持的，但是编译器在实现的时候扩展了char、signed char、unsigned char、enum这几种数据类型。
* 当相邻的成员类型相同时，而且成员的==位宽之和小于sizeof(数据类型)，成员是按照位宽挨着存储的==，直到；如果==位宽之和大于sizeof(数据类型)，超出的成员将从新的存储单元开始==，整体偏移量为该数据类型的整数倍，同时对于整个结构体还要考虑内存对齐。
* 当相邻的成员==类型不相同==时，不同的编译器有不同的实现。在==GCC中，会压缩存储。VC和VS则不会压缩==，是按照结构体内存对齐进行存储的。
* 如果成员之间穿插着==非位域成员，则不会进行压缩==。
* 位域成员往往不占用完整的字节，有时候也不处于字节的开头位置，因此使用`&`获取位域成员的地址是没有意义的，C语言也禁止这样做。地址是字节（Byte）的编号，而不是位（Bit）的编号。 

所以对于这道题，a占用了3bit，下一个成员和a类型不同，在GCC下是可以压缩的，占用4bit，再下一个占用5bit，一共占用12bit。内存对齐，就是2Byte。



[参考文章](http://c.biancheng.net/view/2037.html)



## 9.10 移位 异或 优先级

分析下列程序的结果：

```c
int a=6,b=4;
a^b<<2=?

```

求`a^b<<2`的值？

我的答案：8

正确答案：22

分析：
我开始以为^的优先级比<<的优先级高，所以先进行异或运算，然后进行移位，得到8。实际上<<的优先级要比^的优先级高，所以先进行移位运算，b<<2得到16，6^16得到22.

应该是`a^( b<<2 )`。



## 9.11 结构体元素偏移

```c
//int 占 2 个字节，char 占 1 个字节，float 占 4 个字节
struct stu{
    union{
        char bj[5];
        int  bn[2];
    }class;//5
    char  xm[8];//8
    float cj;//4
}xc;

```

问题：求sizeof(xc)?

我的答案：32

正确答案：20

分析：

无论结构体还是联合体，都讲究一个字节对齐，==按照其内部最大元素内存大小对齐！！！==

所以union中最大元素类型是int，这里是2字节，所以==union按照2字节对齐==，char bj[5]占了5字节，按照2字节对齐的时候再补一个字节，所以==union的大小是6Byte==；在struct中，class已经占了前6字节，==char xm[8]中每一个char占1字节，所以char数组可以紧接着存放8个字节==，现在内存大小为6+8=14字节，由于==float需要4字节对齐，所以float从第16字节开始存储，占用4字节==。至此struct内存大小占用20字节！

> 注意:结构体涉及数组的时候，我觉得可以把数组拆分开看作一个个元素，就好多了，只出现数组是不可以按照数组整体来内存对齐的.

结构体定义如下：

```c
//int 占 2 个字节，char 占 1 个字节，float 占 4 个字节
struct stu{
    union{
        char bj[5];
        int  bn[2];
    }class;//5
    char  xm[8];//8
    float cj;//4
}xc;

```

问题：若xc地址为0X1000，求&xm[0]的值？

我的答案：0X1006

根据上面的内容，union大小为6Byte，所以相对于结构体的偏移地址是6，则紧挨着的xm[0]的地址就是0X1000+6=0X1006



> 为了提高 CPU 的存储速度，编译器会对一些变量的起始地址做了“对齐”处理。
> 对齐方式（变量存放的起始地址相对于结构的起始地址的偏移量） 
> char    偏移量必须为 sizeof(char)  即 1 的倍数 
> int      偏移量必须为 sizeof(int)   即 4 的倍数  (跟编译器有关，有可能是 2)
> float  偏移量必须为 sizeof(float) 即 4 的倍数 
> double  偏移量必须为 sizeof(double) 即 8 的倍数 
> short  偏移量必须为 sizeof(short) 即 2 的倍数 





## 9.12 指针、数组的声明

题目：

用变量a给出下面的定义 

1、一个整型数（An integer）

 2、一个指向整型数的指针（ A pointer to an integer）

3、一个指向指针的的指针，它指向的指针是指向一个整数（ A pointer to a pointer to an intege）

4、一个有10个整型数的数组（ An array of 10 integers）

5、一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers）

 6、 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers）

 7、 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer） 

8、一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer 

答案：
1：`int a`

2：`int *a`

3：`int **a`

4：`int a[10]`

5：`int* a[10]`

6：`int (*a)[10]`

7：`int (*a)(int)`

8：`int (*a[10])(int)`

`[]`的优先级比`*`要高，所以可以根据题中的要求来判断`[]`和`*`的先后执行顺序。

比如5题：一个10个指针的数组，指针指向整型数；首先是一个10个元素的数组，所以首先a[10]，然后指定数组元素是指针指向整型，所以声明元素为`int *`。

再比如6题：一个指针，指向有10个整型数的数组；首先是一个指针，所以先声明指针，即`*a`，然后指针的指向是一个10个元素的整型数组，所以就成了`int (*a)[10]`。

当涉及到函数的时候，分为三部分：函数返回值类型、指向函数的类型、函数的参数类型。指向函数的格式就是加上一个括号，代表函数体。

所以7题分析为：返回值和参数都是整型数，所以`int () (int)`确定了两部分，然后是指向函数的指针，所以就有了`int (*a)(int)`

同理8题：返回值和参数都是整型，指向函数的是一个10个元素数组，数组的元素指向函数，所以就有`int (*a[10])(int)`



## 9.13 负数的求余运算

运行下列语句，求出x的值：

```c
int x=10;
x += 3+x%(-3);//x=x+3+x%(-3)=13+
```

 答案：14

分析：

`x += 3+x%(-3)`中，`+=`运算比较好判断，主要是`x%(-3)`的判断不知道是1还是-1，==在求余运算中，余数的符号与被除数的符号相同==，所以在这里x=10，则得数就是1，即`x += 3+1`易得x的值为14.



## 9.14 阅读代码

阅读下列代码，分析该代码的功能：

```c
char *func(char *dest, const char *src, int count)    
{    
    char *tmp = dest;    
    while (count) {    
        if ((*tmp = *src) != 0)    
            src++;    
        tmp++;    
        count--;    
    }    
    return dest;    
}   
```



分析：

先看参数和返回值，参数中第二个参数是const修饰的（指向的地址不可改变），所以第二个参数位置的字符串肯定是不能改变的，然后返回值也是一个char类型的指针，初步推断可能是一个字符串操作类的函数。

然后往函数内部分析，先创建了一个字符指针，指向传进来的dest

在while中根据count的大小进行遍历

` if ((*tmp = *src) != 0) `中，先是将`*tep = *src*`然后判断*tmp是否为空，相当于字符拷贝，然后自增、coun自减

可以看出此函数就是拷贝字符串的函数。

实际上strncpy的源码如下：

```c
/*   

 * strncpy - Copy a length-limited, %NUL-terminated string   

 * @dest: Where to copy the string to   

 * @src: Where to copy the string from   

 * @count: The maximum number of bytes to copy   

 *   

 * The result is not %NUL-terminated if the source exceeds   

 * @count bytes.   

 *   

 * In the case where the length of @src is less than that of   

 * count, the remainder of @dest will be padded with %NUL.   

 */   

char *strncpy(char *dest, const char *src, size_t count)    //从 src 复制count个字符 到 dest 
{    
    char *tmp = dest;    
    while (count) {    
        if ((*tmp = *src) != 0)    //把 src 的值 复制到 dest ，如果 src 的值 非空，那么指针自加。
                                   //否则 指针不加，src 后续都是指向 0 ，即字符串结束,后续的 dest值都为 0

            src++;    
        tmp++;                     // dest 的指针 自加
        count--;                   //最大计数值 减 1
    }    
    return dest;    c
}   
```


##  9.15 逗号表达式细节

求如下程序的输出：

```c
int a[3][2] = {(0,1),(2,3),(4,5)};
int *p = a[0];
printf("%d",p[0]);
```

答案：1

分析：
这里分析一下程序，p指针指向a[0]，也就是指向二维数组的首地址，所以p[0]的值就是二维数组的第一个值。

再看一下二维数组的定义：`int a[3][2]={(0,1),(2,3),(4,5)}`，这里要注意，这里的初始化不是分段赋值，正常的分段赋值应该是这样：`int a[3][2]={{0,1},{2,3},{4,5}}`，这里是逗号分隔的，所以是逗号表达式，实际的是连续赋值：`int a[3][2]={1,3,5}`，所以p[0]=1.


## 9.16 变量的存储布局

分析以下程序运行时各个变量的内存分布：

```c
int a = 0;//全局初始化区：.data
static int b = 20;//静态初始化区：.data
char *p1;//全局未初始化区：.bss
const int A = 10;//.rodata

int main(void) {
    int b;//栈
	char s[] = "abc";//栈
    char *p2;//栈
    static int c = 0;//静态初始化区：.data
    char *p3 = "123456";//.rodata  常量区  p3在栈
    p1 = (char*)malloc(10);//堆
    p2 = (char*)malloc(10);//堆
    strcpy( p1, "123456" );//123456\0 在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方
    
    return 0;
}
```

* 栈区（stack）：由编译器自动分配释放，放置函数的参数值和局部变量
* 堆区（heap）：一般由程序员分配释放，若不释放，程序结束时由系统释放
* 全局变量、静态变量(const)：放在.data段
* 未初始化的全局变量、静态变量：放在.bss段
* 文字常量：常量区，.rodata段，程序结束后由OS释放

全局变量 、静态变量初始值为0，局部变量，自动变量初始值随机分配值。

注意：

```c
void main()   
{   
    char *p="abcde";       //.rodata
    char a[]="abcde";      //.data
    p[1]='m';                  //错误，修改字符串常量
    a[1]='m';                  //正确，修改元素
}
```

static修饰全局变量是限制其作用域只在当前文件中，static修饰局部变量是扩展其作用域为当前文件，相当于全局变量。

## 9.17编译器角度看：数组、指针

数组名和指针是两个往往很容易让人们混淆的概念，很多人以为数组名就是一个指针，也有很多人知道数组名不同于指针但是仅知道数组名的值不能像指针一样改变，例如你可以写出下面这样的代码：

复制

```
int *p;
p++;
```

却不能写这样的代码：

复制

```
int a[];
a++;
```

那么数组名跟指针之间到底有什么区别呢？
**第一** ，在声明上，除了作为函数参数的数组名总是编译器转化成指针，其他情况下，数组名就是数组名，指针就是指针，二者不能混淆，你不能在一个文件中定义一个数组，而在另一个文件中把它声明成一个指针。 

```
char a[];  //定义一个数组a
 
extern char* a; //在另一个文件中将a声明成一个指针
```

在编译器中，符号表用来存放C语言中有关标识符的属性信息，这些信息集中反应了标识符的特征属性。等到词法分析到代码声称的各个阶段的时候，编译器需要根据源代码提出的要求，从表中获取不同标识符的不同属性。值得注意的是，数组标识符的属性和指针是完全不同的。因此，在一个文件中定义一个数组的时候，编译器会把它记录在符号表中，而在编译器分析另一个文件中的声明时，通过符号的语义检查发现不一致。也许这样的声明可以编译通过(在gcc下通过了)，但是把一个数组名当成一个指针来使用，别指望它能运行起来。

**第二**，指针是一个变量，而数组名不是。数组名是数组的首地址，即它本身就是一个地址，对应到汇编语言级别就是一个常量，一个固定的数（地址）。因此数组名不能进行++,--等运算。在大多数编译器中，对数组的引用a总是被编译器改写成*(a+i)的格式。也就是说，编译器每遇到a，都会把它当作*(a+i)来处理。我们都知道，*addr表示内存中（addr）的位置存储的值，比如*0x8048000就表示地址为0x8048000的内存中所存储的值。所以a就表示a的值加上i所得到的数作为一个内存地址里面所存储的值。



**第三**，对数组的引用，如a，或* (a+1)，需要访存一次；而对指针的引用，如* (p+1)，需要访存两次。如果理解了第二条的解释，这个应该就不难理解。因为a被认为是常数，所以取*(a+1)的值只需将a所表示的常数加1，然后从得到的地址里访存取一次即可。而对于指针，需要先从&p这个地址里把p的值取出来，然后加1，再从得到的地址里访存取一次，一共需要两次访存。

**第四**

 假设a是一个数组名，而p是一个指针，当你使用 a 和 &a 时，得到值是一样的，都是数组的起始地址。而使用 p 和 ＆p 时，得到的值是不一样的， p 表示指针 p 所指向的地址，而 &p 表示 p 这个变量的地址。再假设 

```
p = a;
```

则 p 就表示数组a的起始地址，而&p是存储数组a的起始地址的那个地址。



## 9.18 C++中类的定义

C++中，类是一个用户自定义的数据类型，形式如下：

```cpp
class name {
    成员列表
};
```

成员列表是类成员的集合，数目可以任意多对，类后面必须加上；作为结束。

* 类成员必须在内部声明，一旦类的定义完成之后，就没有任何其他方式增加减少成员了。
* 一般将数据成员封装起来，成员函数作为接口，==外部调用成员函数访问成员数据==。
* 类函数的==声明必须要在内部声明，但是定义可以在class内部，也可以在外部==。
* 内部定义的函数就是内联函数，此种定义方法与一般的函数定义无异。
* ==外部定义class函数的时候，必须要加上作用域==，以表明此定义的函数是某一个class中的成员函数。
* ==类相当于一种数据结构，数据类型是不占用空间的==，但是当用一个类实体化一个对象的时候，就会为对象分配存储空间。
* 类的空间大小取决于class中数据成员的大小，以及排布（==和struct的空间大小原理相似==）

## 9.19 C++中类成员的访问控制

对C++中成员的访问，就是访问数据或者函数，面向对象的编程中，经常把数据封装起来，通过调用成员函数；来访问成员数据。class中，每个成员的访问属性有：public、private、protected

* 成员数据一般为private，成员函数一般为public，外部通过public的成员函数来访问private的成员数据。

* class中默认为private



## 9.20 C++中构造函数

实体化一个对象的时候，一般要进行初始化操作，我们可以在class中写一个成员函数来初始化class成员数据，但是也可以直接使用构造函数来初始化成员数据（自动调用）。

* class中成员数据在定义的时候是不可以初始化的，即：`int a = 1;`是不允许的。
* 构造函数要和class名称一致，而且不能指定返回值。
* 构造函数是一种特殊的成员函数，不需要人为调用，在实体化对象的时候会自动调用执行。
* 没有构造函数class会报错，但是一般用户不声明构造函数的时候，IDE就会自动生成一个默认的构造函数

## 9.21数组、字符串的存取效率

在程序中，对数组和字符串的存取，哪个更有效率？

先看一段程序：

```c
#include "stdio.h"
int main() {
    char a = 1;
    char c[] = "123456789";
    char *p  = "123456789";
    a = c[1];
    a = p[1];
    return 0;
}

```

声明了一个数组c和一个字符串p，然后同样读取其中的一个值，对应的汇编代码如下：

```
10:a=c[1];
004010678A4DF1 movcl,byteptr[ebp-0Fh]
0040106A884DFC movbyteptr[ebp-4],cl
11:a=p[1];
0040106D8B55EC movedx,dwordptr[ebp-14h]
004010708A4201 moval,byteptr[edx+1]
004010738845FC movbyteptr[ebp-4],al
```

可以看出对于a = c[1]的操作，是直接将数组中字符串的元素读取到c1寄存器中（也就是a）

对于a = p[1]的操作，显示将指针的值edx中，再根据地址读取字符元素

所以数组的读取比字符串的读取要有效率，即在栈上的数组比指针指向的字符串要读取快。


## 9.22 求一个int数据 二进制中1的个数

```cpp
#include <iostream>
using namespace std;

int fun (int x) {
    int count = 0;
    while (x) {
        x &= (x-1);
        ++count;
    }
    return count;
}


int main() {
    int x = 0;
    cin>>x;
    cout<<"ans is :"<<fun(x)<<endl;
    return 0;
}
```

分析：把一个整数减去1，再和原整数做 & 运算，就会把整数最右边一个1变成0，通过while(x)来计数有多少个1.




## 9.23 指针与引用的区别

* 引用只是变量的一个别名，内部是依靠==只读指针实现的==，引用本身不占用内存空间，不能建立数组的引用
* 引用在初始化的时候就要指明赋值；而且指针可以在允许的情况下任意时刻赋值
* 引用不能为NULL；指针可以为NULL
* 引用保存的是==被引用变量的地址==
* `sizeof 引用`的大小是被==引用变量的大小==；`sizeof 指针`的大小是==指针本身的大小==
* ==引用在源代码级相当于一个普通的变量，但是作为函数参数时，传递的是变量地址==
* 指针可以有多级，引用只能一层

## 9.24 编写strcpy

**已知strcpy的函数原型：char *strcpy(char *strDest, const char *strSrc)其中strDest 是目的字符串，strSrc 是源字符串。不调用C++/C 的字符串库函数，请编写函数 strcpy。**

```cpp
#include <stdio.h>
#include <assert.h>

cahr* strcpy (char *strDest, const char *strSrc)
{
    assert ((strDest != NULL) && (strSrc != NULL));
    char *addr = strDset;
    while ((*strDest++ = *strSrc++) != '\0')；
        
    return addr;
}
```



* assert是宏，不是函数，其的原型定义在<assert.h>中，其作用是如果它的条件返回错误，则终止程序执行
* strcpy函数会连‘\0’一起拷贝
* 要用一个临时的变量保存目标字符串的首地址，最后返回这个临时变量
* 返回值为char* 是为了支持链式表达式



## 9.25引用作为函数参数的的注意

* 不能返回局部变量的引用
* 不能返回函数内部new产生的引用
* 传递引用给函数与传递指针给函数的效果一样，但是指针传递参数在函数中要分配空间的，而且在函数内使用指针变量名进行运算，程序的可读性会比较差
* 使用引用传递进来的参数，在函数运行过程中是没有产生实参的副本，是直接对地址进行操作的，所以当形参传递的数据比较大的时候，引用传递参数效果比较好



## 9.26 如何确认一段程序是C还是C++编译的

使用C++中的自定义宏来确定：

```cpp
#ifdef __cplusplus
	cout<<"C++"<<endl;
#else
    cout<<"C"<<endl;
#endif
```
## 9.27 给出各数据类型与零值比较的代码

分别给出BOOL，int，float，指针变量 与“零值”比较的 if 语句（假设变量名为var）

* 对于==逻辑判断==，使用`if (!var)`来判断是否为真
* 对于==整型数值判断==，使用`if (var == 0)`判断是否为0
* 对于==浮点型数值判断==，使用`if ((var >= 0.00001) && (var <= 0.00001))`之类的，进行一个范围判断
* 对于==指针判断==，使用`if (var == NULL)`来判断指针指向是否为空


## 9.28 C++程序中调用被C编译器编译后的函数，为什么要加extern”C”

由于C++支持函数重载，C不支持函数重载，而且函数的重载表面上看起来函数名一模一样，实际上C++编译器会在编译的时候给重载的函授根据参数的不同分配不同的名字，比如：

```cpp
void fun (int x, int y);
```

C编译器编译之后，该函数在库中的名字为：_foo

C++编译器编译之后，该函数在库中的名字为：_foo_int_int 

所以，为了区别这种名字匹配问题，C++提供了C链接交换指定符号extern “C”。当C++程序引用C的函数时，它会按照重载后的名字去目标文件（.obj）中去寻找对应的函数，而目标文件中存放的却是C版本的函数，名字对不上，所以根本找不到！




## 9.29 堆栈的区别详解

从以下几点分析堆栈的区别：
1.申请方式

2.申请后系统的响应

3.申请大小的限制

4.申请效率比较

5.存储的内容

6.存取效率比较

**1.申请方式**

stack：是由系统自动分配的，比如进入函数的参数、函数内声明的一些局部变量；

heap：由程序员申请的，C中经常用malloc函数（使用时要指明申请空间大小），C++中使用new函数；

要注意的是：`p = (int*) malloc (10)`中，==虽然申请的空间是堆上的，但是指针p在栈上，指向堆。==

**2.申请后系统的响应**

stack：只要申请的空间大于栈剩余的空间，系统就会自动为其提供空间，否则将报错栈溢出。

heap：操作系统有一个==记录空闲内存地址的链表==，当收到请求之后，会遍历链表，找到第一个空间大于申请空间的堆结点，将该结点的空间分配出去。当然，系统也==会记录分配出去的空间的首地址以及申请空间的大小，以便于后面释放空间。==

**3.申请大小限制**

stack：windows中是==向低地址扩展的数据结构，是一块连续的内存空间==。

heap：堆是==向高地址扩展的数据结构，由于系统用链表来存储空间地址，==所以不是连续的；链表的遍历方向是由低地址到高地址；==堆的大小取决于系统中有效的虚拟地址的大小。==

**4.申请效率的比较**

stack：由系统自动分配，速度快。

heap：由new分配的内存，速度比较慢，而且==容易产生内存碎片==，但是用起来方便。

**5.存储的内容**

stack：==函数调用的时候，第一个进栈的是函数调用语句之后的下一条可执行语句的地址，随后入栈的是函数的各个参数，遵循从右往左的入栈顺序（大多数情况），随后入栈的是函数中的局部变量；函数调用完毕之后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存储的地址，也就是第一个进栈的：函数调用语句之后的第一个可执行语句的地址，程序由该点继续运行。==

heap：一般在堆的头部用一个字节存放堆的大小，堆中的具体内容由程序员安排。

**6.存取效率的比较**

说明程序如下：

```c
int main ()
{
    char s1[] = "aaaaaaaa"; //字符串放在 栈
	char *s2  = "bbbbbbbb"; //字符串放在 常量区
    char s = 'c';
    
    s = s1[1];
    s = s2[1];
    
    return 0;
}
```

其中：`char s1[] = "aaaaaaaa";`是在函数运行的时候赋值的，`char *s2  = "bbbbbbbb";`是在编译的时候就确定的！而且在存取速度上来看，栈上的数据比常量区的字符串快。



## 9.30 volatile 详解

**volatile**是一个C语言关键字，修饰变量的时候表示：这个变量的值不可以被优化，==也就是说每次用到变量的值，都要去变量申请内存空间去，而不是去使用保存在寄存器中的备份。==

嵌入式程序员必须要知道的几点volatile的应用如下：

* 硬件寄存器的值，比如一些状态寄存器的值。

* 中断服务程序中访问到的一些非自动的变量，这些变量往往是反应程序运行状态或者是外部输入情况的，所以每一次的改变都要被记录下来。

* 多线程应用中被几个任务共享的变量。

下面通过几个例子来进一步熟悉volatile的用法：
例一：一个参数既可以是const又可以是volatile吗？

可以的，const表示变量不可以被程序修改，volatile表示变量每一次修改都要被记录。所以const和volatile可以同时用来修饰一个只读状态寄存器，只读的状态寄存器是不可以被程序修改的，而且寄存器的每一次改变都要被记录下来，不能被优化。



例二：一个指针可以是volatile吗？
可以的，当我们在中断服务程序中去修改一个指向字符串的指针的时候，就会用到volatile来修饰这个指针



例三：下列这段程序有什么错误？

```c
int square (volatile int *ptr)
{
    return *ptr * *ptr;  //返回平方值
}
```

首先返回值应该是long，要考虑到数据溢出。

其次，我们要明白，volatile修饰的变量就默认为会被意想不到的改变，所以而指针传进来的是一个地址，地址中的值可能随时改变。

然后，如果使用`*ptr * *ptr`进行平方运算，编译器会将代码优化为下列形式：

```c
int a, b;
a = *ptr;
b = *ptr;
return a * b;
```

这个时候由于*ptr的值可能被意想不到的改变，所以a、b的值可能不相同，会造成程序错误。

所以最好的方法就是一次将*ptr赋值给一个变量，然后去求这个变量的平方（利用自身乘以自身），程序如下：

```c
long square (volatile int *ptr)
{
    int a;
    a = *ptr;
    return a * a;
}
```

# 十月



## 10.1 内存碎片 



**内部碎片的产生：**因为所有的内存分配必须起始于可被 4、8 或 16 整除（视 处理器体系结构而定）的地址或者因为MMU的分页机制的限制，决定内存分配算法仅能把预定大小的内存块分配给客户。假设当某个客户请求一个 43 字节的内存块时，因为没有适合大小的内存，所以它可能会获得 44字节、48字节等稍大一点的字节，因此由所需大小四舍五入而产生的多余空间就叫内部碎片。

**外部碎片的产生：** 频繁的分配与回收物理页面会导致大量的、连续且小的页面块夹杂在已分配的页面中间，就会产生外部碎片。假 设有一块一共有100个单位的连续空闲内存空间，范围是0~99。如果你从中申请一块内存，如10个单位，那么申请出来的内存块就为0~9区间。这时候你 继续申请一块内存，比如说5个单位大，第二块得到的内存块就应该为10~14区间。如果你把第一块内存块释放，然后再申请一块大于10个单位的内存块，比 如说20个单位。因为刚被释放的内存块不能满足新的请求，所以只能从15开始分配出20个单位的内存块。现在整个内存空间的状态是0~9空闲，10~14 被占用，15~24被占用，25~99空闲。其中0~9就是一个内存碎片了。如果10~14一直被占用，而以后申请的空间都大于10个单位，那么0~9就 永远用不上了，变成外部碎片。



## 10.2 数组、字符串

```cpp
char str1[] = "abc";
char str2[] = "abc";
const char str3[] = "abc";
const char str4[] = "abc";
const char *str5 = "abc";
const char *str6 = "abc";
char *str7 = "abc";
char *str8 = "abc";

cout << ( str1 == str2 ) << endl;
cout << ( str3 == str4 ) << endl;
cout << ( str5 == str6 ) << endl;
cout << ( str7 == str8 ) << endl;
```

判断如上程序的输出：
0  0  1  1

原因是str1、2、3、4都是数组变量，strx代表数组的首地址，而数组里面的内容都是栈上面的，所以指向各不相同；但是str5、6、7、8是指针变量，指向的是字符串常量，相同的字符串在常量区的地址都是一样的。




## 10.3 越界读写字符串

分析如下程序：

```c
int main (void)
{
    char a = 'a';
    char *str = &a;
    
    strcpy(str, "Hello C");
    printf(str);
    
    return 0;
}
```

指针str指向变量a的地址，后面又将字符串“Hello C”复制在指针所指向地址上，虽然可能正常输出结果，但是会因为越界读写内存造成程序崩溃。




## 10.4 malloc内存泄漏+free非法访问+二级指针传参

程序如下：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void GetMemory(char *p)
{
    p = (char*)malloc(100);
    
    strcpy(p, "Hello world");
}

int main(void)
{
    char *str = NULL;
    
    GetMemory(str);
    printf("%s\n", str);
    free(str);
    
    return 0;
}
```

程序会崩溃，原因：malloc指向了新地址导致内存泄漏和free导致访问非法内存

**首先要明白如下概念：**

**C函数的所有参数都是传值调用，即函数会获得参数值的一份拷贝！！！即函数可以修改传递进来的参数值，而不必担心会影响到调用程序实际传给函数的参数值。**

**如果参数是数组名，函数中就可以通过访问数组下标来修改数组中的元素，这样岂不是函数可以修改调用程序实际传给函数的参数值吗？这样岂不是与上面所说：函数获得的只是参数值的一份拷贝，不会修改原参数值的说法吗？**

**实际上这种情况也是符合上述说法的，数组参数传递的是数组名，实际数组名的值就是一个指针，指针的值就是地址，强调一下，是地址！！！所以函数获取的还是数组地址的一份拷贝，在函数中通过这份拷贝的地址同样可以访问到原数组中的元素，从而修改数组的元素。**

==回归到程序上==：指针p传递的其实就是str地址的一份拷贝，在函数中修改了p指针的指向（指向malloc函数分配内存空间），对原来的str指针造不成丝毫影响。因为没有在str指向的地址上进行修改，而是在新的地址上进行修改（strcpy），所以对原来的str所指向的地址空间造不成任何影响。即str指向的还是NULL，但是对一个NULL指针进行free操作就是==非法访问==了。而且在malloc之后没有进行free释放内存空间，也造成了==内存泄漏==。



**解决方法：**

使用二级指针传递参数，什么时候用到二级指针呢？就是**在函数外定义一个指针，在函数内给指针赋值，要求函数结束后指针的赋值生效，这样就需要二级指针！**

对于参数传递来说，传递进入函数的始终是参数的一个副本（拷贝值）。**所以一级指针作为参数时，传入的是指针指向地址的副本，随后malloc改变的是副本的值，malloc作用不到原始指针；==二级指针作为参数时，传入的是指针变量本身地址的副本，malloc改变的是基于原指针地址上的指向的地址==，所以可以作用到原指针；**

修改后的程序如下：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void GetMemory(char **p)       //参数 char **p 传递的是指针变量的地址
{
    *p = (char*)malloc(100);   //malloc修改的是基于原指针变量的指向的地址，所以可以作用到原指针
    strcpy(*p, "Hello world");
}

int main(void)
{
    char *str = NULL;

    GetMemory(&str);           //传入的是指针变量的地址
    printf("%s\n", str);
    free(str);                 //释放内存空间

    return 0;
}
```





> free:
>
> 传递给free的指针必须是从malloc、calloc、realloc返回的指针，否则让free释放一块非动态分配的内存可能导致程序立即终止或者晚些时候终止。有时候使用free释放一块动态分配的内存的一部分也可能引起这种错误。注意：不要访问free释放的内存。
>
> 内存泄漏:
>
> 内存泄漏是指内存被动态分配之后，当它不再使用时未被释放就会造成内存泄漏。内存泄漏回增加程序的体积，还有可能导致程序或者系统的崩溃。




## 10.5 求含位域的结构体大小

```c
struct s1
{
    int a : 8;
    int b : 4;
    int c : 3;
    double d;
};

struct s2
{
    int a : 8;
    int b : 4;
    double c;
    char d : 3;
};

struct s3
{
    int a : 5;
    int b : 6;
};


```

s1 = 2+6+8=16

a、b、c一共占2Byte；前三个对齐后再加6Byte；d占8Byte

s2 = 2+6+8+8=24

a、b一共占2Byte；对齐后再加6Byte；c占8Byte；d对齐后占8Byte

s3 = 1+1+2=4

对齐后占4Byte


## 10.6 判断程序输出

判断如下程序输出：

```c
int sum(int a)
{
    auto int c = 0;
    static int b = 3;
    c += 1;
    b += 2;
    return (a + b + c);
}

int main()
{
    int i;
    int a = 2;
    
    for (i = 0; i < 5; i++) {
        printf("%d\n", sum(a));
    }
}
```

程序会调用五次sum函数，每次传入的参数都是a=2

对于函数宿命来说，返回a+b+c，其中a来自参数（不变）；c来自函数内的局部变量，每次进入函数的时候重新申请，所以也是不变；b是static修饰的，相当于全局变量，所以sum的返回值是：2+1+(b+2)其中b的值每次改变都保留

所以经过五次循环sum，得到结果为：
8
10
12
14
16

## 10.7 指针移动

判断如下伪代码输出：

```c
int a[3] = {0, 1, 2};
int *p, *q;

p = a;
q = &a[2];

printf("%d\n", a[q - p]);
```

答案：2

也就是`a[q - p] = a[2]`

a是一个int型数组，p、q是int型指针，p指向数组的首地址，q指向数组第三个元素的地址。

如果按照字节大小计算的话，p、q指针相差2*4个字节，如果这样的话，q-p的值就为8

但是指针直接的计算以指针所指的数据类型来衡量，即q - p的值为2，所以`a[q - p] = a[2]`。




## 10.8 带符号的位域

写出下列代码的输出：

```c
typedef struct
{
int a : 2;
int b : 2;
int c : 1;
}test;

test t;
t.a = 1;
t.b = 3;
t.c = 1;

printf("%d", t.a);
printf("%d", t.b);
printf("%d", t.c);
```

输出为：1 -1 -1

虽然位域的大小只有一两个位，但是数据类型是int型，必须考虑符号位的存在，所以也将符号位计算在内。

> 计算机中以补码的方式存储数据


## 10.9 涉及strcpy的程序分析

分析如下代码，找出不妥的地方：

```c
void test(void)
{
    char string[10], str[10];
    int i;
    
    for (i = 0; i < 10; i++) {
        str[i] = 'a';
    }
    strcpy(string, str);
}
```

首先，str数组内所有的成员都是‘a’，结尾没有结束符‘\0’，所以str当作字符串的时候不能够结束，当str数组作为strcpy的参数的时候，是不确定复制到string的元素个数的，也就是说从str复制到string的字节数具有不确定性。要知道strcpy的工作原理就是遇到字符串结束符‘\0’作为标志，这里的str没有结束符，那到时候复制到string中的后续内容就不确定了。

正确的程序应该修改为如下：

```c
void test(void)
{
    char string[10], str[10];
    int i;
    
    for (i = 0; i < 9; i++) {
        str[i] = 'a';
    }
    str[9] = '\0';             //加上结束符！！！
    strcpy(string, str); 
}
```

## 10.10 运算符优先级问题（一）

分析如下程序输出：

```c
int arr[] = {6, 7, 8, 9, 10};
int *ptr = arr;
*(ptr++) += 123;
printf(" %d %d ", *ptr, *(++ptr));
```

程序的重点在于第三行和第四行代码：

第三行代码：`*(ptr++) += 123`要明白运算符的优先级，这里涉及到的运算符有：()、*、++、+= 。

他们的**优先级为：() > ++ > * > +=** 。所以先执行（）里面的++运算，即ptr++，意为当前指令执行完毕之后ptr指向下一个地址；然后是取值符号*，取当前ptr指向的值—arr[0]，即6；然后是+=运算，相当于arr[0] += 123，这个运算使得arr[0] = 129；最后ptr指向arr[1]，即 ` *ptr = 7 `。

第四行代码：**考察的是printf函数的入栈顺序，一般是从右向左**，所以先执行`* (++ptr)`，再执行`*ptr`,所以右边的相当于arr[2]，左边的相当于arr[2]。

即输出： 8  8

## 10.11 函数形参问题

分析如下程序的输出：

```c
void fun(int m, int n)
{
    printf("m = %d, n = %d\n", m, n);
}

int main(void)
{
    int k = 3;
    fun(k += 3, ++k);
    printf("k = %d", k);
    
    return 0;
}
```



主要考察是调用函数的时候参数的入栈顺序以及变量的运算，**参数入栈顺序一般是从右到左**，所以先执行++k，将4传给n；再执行k += 3将7的值传给m。注意这里是k做运算之后才传入的函数，所以**k += 3, ++k并不是在调用函数的栈中执行的，所以k的值是保存下来的**，所以最终输出为：

m = 7, n = 4 

k = 7

>这种方式和编译器中得函数调用关系相关即先后入栈顺序。不过不同编译器得处理不同。也是因为 C 标准中对这种方式说明为未定义，所以各个编译器厂商都有自己得理解，所以最后产生得结果完全不同。因为这样，所以遇见这种函数，我们首先要考虑我们得编译器会如何处理这样得函数，其次看函数得调用方式，不同得调用方式，可能产生不同得结果。最后是看编译器优化。  





## 10.12 二级指针偏移

分析下面程序：

```c
#include <stdio.h>

void fun(int b[][3])
{
	++b;
    b[1][1] = 120;
}

int main(void)
{
    int a[][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };
    
    fun(a);
    printf("a[2][1] = %d\n", a[2][1]);
    
    return 0;
}
```

首先要了解数组传入函数后的变化**：我们知道数组传入函数的时候，会转换为指针，但是对于二维数组，只转换一次**，即`int b[][3]`传入函数的时候是以

**`int (*b)[3]`的形式，即一个指向数组的指针，数组中有三个元素。所以传入a后，相当于`b = a[0]`。**

**`++b`代表指针b移动一个步长的位置，这里b指向一个三个元素的int型数组，所以`++b`之后`b = a[1][]`。**

**指向`b[1][1] = 120`， 其中`b[1][1]`相当于`*(*(b+1)+1)`，相当于指针b偏移了一个步长之后又偏移了一个元素的位置，用a表示`a[1+1][0+1]`即`a[2][1] = 120`，所以printf输出的就是120。**




## 10.13  #ifdef与#if define 的区别

用一段程序说明：

```c
#include <stdio.h>
#define A
#define B
void test(int a,int b)
{
}

int main(void)
{
#if 0
    #ifdef A&&B
    test(printf("a\n"),printf("b\n"));
#endif
#endif

#if  defined(A)&&defined(B)
    test(printf("a\n"),printf("b\n"));
#endif

    return 0;
}
```

如果是`#if defined(A)&&defined(B)`的形式，输出：

b

a

如果是`#ifdef A&&B`的形式，会提示：
<img src="../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/image-20201017102017535.png" alt="image-20201017102017535" style="zoom:200%;" />

因为\#ifdef虽然我们最常见也用得最多，可是#if defined(XXX)却可以有 &&，||，！，逻辑与，逻辑或，逻辑非等操作，而#ifdef却不支持这样的特性。



## 10.14指针实现交换数据时的溢出情况

程序如下：

```c
void swap(int *a, int *b)
{
    *a = *a + *b;
    *b = *a - *b;
    *a = *a - *b;
}
```

请问上述程序可否实现两个int数据的交换？看起来没毛病，可是容易忽略一个问题，那就是int是有符号数据的溢出！

![image-20201017103737242](../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/image-20201017103737242.png)



**只有当a、b同符号的时候才可能发送溢出！！！**因为这里有加减操作，所以当两个同符号的数据相加的时候就有可能溢出。

比如：

交换-5， -7。 以4bit为例。 

  -5 = 1011 （补码）   -7 = 1001 （补码） 

  （-5）+ （-7）= **10100**=0100=4 （溢出后为4） 

  4-（-7）= 4 +７＝0100 + 0111 = 1011 = -5的补码 

  4-（-5）= 4 + 5 = 0100 + 0101 = 1001 = -7的补码

注意，函数是在第一步的时候可能溢出，但是后面的操作是基于溢出的数据的，而且后面又可以把溢出的部分减回来，所以这里虽然可能会发送溢出，但是仍然可以得到正确的数据。



## 10.15 三目运算的数据转换

程序如下：

```c
#include <stdio.h>

void test()
{
    printf("int:    %d\n", sizeof(int));
    printf("double: %d\n", sizeof(double));
    printf("test1: %d\n", sizeof(100 < 1 ? 0.1 : 1));
    printf("test2: %d\n", sizeof(100 > 1 ? 0.1 : 1));
}

int main(void)
{
    test();
    return 0;
}
```

输出结果为：

```
int:    4
double: 8
test1: 8
test2: 8
```

如果按照我们分析，`(100 < 1 ? 0.1 : 1)`输出的会是1，也就是int型数据，但是实际上被转换为double类型了。

实际上三目运算最后输出的是一个变量，在一个表达式中，数据格式要统一，所以在得出运算之前就将所有变量转换为同一种数据格式了。



## 10.16 ARM子程序设计及调用涉及的指令

　在ARM汇编语言程序设计中，经常用到子程序设计及调用，与子程序设计与调用无关的指令或伪指令是(　　)。

　　A.BL SerchMin

　　B.IMPORT SerchMin

　　C.MOV PC，LR

　　D.B SerchMin



答案是：D

* A：子程序调用一般通过BL命令实现。
* B：IMPORT是伪指令，用于通知编译器要使用的标号在其他的源文件中定义，需要在当前源文件中引用。
* C：MOV PC，LR 是在子程序返回时的跳转。

所以选D



## 10.17 JTAG调试技术

下面有关片上调试技术的描述语句中，不恰当的是(　　)。

　　A.边界扫描技术是调试硬件芯片及目标机电路板的一种常用调试技术

　　B.JTAG组织所研究的测试访问端口和边界扫描结构标准，成为了片上测试技术的一种国际标准，即俗称的JTAG标准

　　C.使用片上调试技术进行嵌入式系统目标机调试时，无需目标存储器，也不占用目标机任何I/O端口

　　D.经常用于嵌入式系统设计中的微处理器(如：MCS-51、DSP、ARM)都支持JTAG标准的片上调试技术



答案是：D

* A：边界扫描测试技术是**对芯片或印制电路板**进行片上调试最常用的一种技术。
* B：JTAG是IEEE下的一个组织，**研究测试访问端口和边界扫描结构的标准**，其研究结果俗称JTAG标准。
* C：使用JTAG进行嵌入式系统的调试，无需目标存储器，也不占用目标机任何I/O端口。
* D：MCS-51单片机不支持JTAG调试标准，其软件固化要使用称为“编程器”的设备来进行。



>JTAG(Joint Test Action Group，联合测试工作组)是一种国际标准测试协议（IEEE 1149.1兼容），主要用于芯片内部测试。现在多数的高级器件都支持JTAG协议，如[DSP](https://baike.baidu.com/item/DSP/74514)、[FPGA](https://baike.baidu.com/item/FPGA)器件等。标准的JTAG接口是4线：TMS、TCK、TDI、TDO，分别为模式选择、时钟、数据输入和[数据输出](https://baike.baidu.com/item/数据输出/5885826)线。

>一个含有JTAG Debug接口模块的CPU，只要时钟正常，就可以通过JTAG接口访问CPU的内部寄存器和挂在CPU总线上的设备，如FLASH，RAM，SOC（比如4510B，44Box，AT91M系列）内置模块的寄存器，像UART，Timers，GPIO等等的寄存器。

>仿真器是用以实现硬件仿bai真的硬件。仿真器可以du实现替代单片机、zhiARM对程序dao的运行进行控制，例如单步，全速，查看资源断点等。尽管软件仿真具有无需搭建硬件电路就可以对程序进行验证的优点，但无法完全反映真实硬件的运行状况，因此还要通过硬件仿真来完成最终的设计。 目前的开发过程中硬件仿真是必需的。
>JTAG和J-LINK是两种仿真器 二者选其一就可以了
>Jlink仿真需要自己的软件，但是支持的芯片多一点；
>而JTAG不需要专业的软件，但是支持的芯片少一点。
>使用集成开发环境配合 JTAG 仿真器进行开发是目前采用最多的一种调试方式。




## 10.18 ARM内核处理器区别

 以下关于ARM处理器内核说法正确的是(　　)。

　　A.经典ARM处理器包括Cortex-M、Cortex-R和Cortex-A三大类

　　B.Cortex-A系列为应用Cortex处理器，主要面向高端应用设计

　　C.Cortex-M系列为面向控制领域的实时嵌入式处理器

　　D.ARM11性能优于Cortex-A5，但低于Cortex-A15

答案是：B

ARM公司在经典处理器ARM11以后的产品改用Cortex来命名，将Cortex分为A、R和M三种类型，Cortex系列属于ARMv7架构，这是ARM公司最新的指令集架构，而我们比较熟悉的三星的S3C2410芯片是ARMv4架构，ATMEL公司的AT91SAM9261芯片则是ARMv5架构。ARM在最初的处理器型号都用数字命名，最后一个是ARM11系列，在应用ARMv7架构后，推出了Cortex这一系列，老式的则命名为Classic系列。

ARMv7架构定义了三大分工明确的系列：

* Cortex-A：基于v7A架构，面向尖端的基于虚拟内存的操作系统和用户应用
* Cortex-R：基于v7R架构，针对实时系统
* Cortex-M：基于v7M架构，针对微控制器和低成本应用提供优化



>ARMv7架构是在ARMv6架构的基础上诞生的。该架构采用了Thumb-2技术，Thumb-2技术是在ARM的Thumb代码压缩技术的基础上发展起来的，并且保持了对现存ARM解决方案的完整的代码兼容性。Thumb-2技术比纯32位代码少使用 31％的内存，减小了系统开销。同时能够提供比已有的基于Thumb技术的解决方案高出38％的性能。ARMv7架构还采用了NEON技术，将DSP和媒体处理能力提高了近4倍，并支持改良的浮点运算，满足下一代3D图形、游戏物理应用以及传统嵌入式控制应用的需求。此外，ARMv7还支持改良的运行环境，以迎合不断增加的JIT(Just In Time)和DAC(DynamicAdaptive Compilation)技术的使用。另外，ARMv7架构对于早期的ARM处理器软件也提供很好的兼容性。

>ARM7：ARMv4架构，ARM9：ARMv5架构，ARM11：ARMv6架构，ARM-Cortex 系列：ARMv7架构 ARM7没有MMU(内存管理单元)，只能叫做MCU（微控制器），不能运行诸如Linux、WinCE等这些现代的多用户多进程操作系统， 因为运行这些系统需要MMU，才能给每个用户进程分配进程自己独立的地址空间 。



参考链接：https://zhuanlan.zhihu.com/p/92315825

## 10.19 main的参数

ANSI-C(美国国家标准协会,C的第一个标准ANSI发布)在C89/C99\中main()函数主要形式为:

```c
int main(void);
int main(int argc, char *argv[]);
```

其中的`int main(int argc, char *argv[])`两个参数的作用如下：

* argc：argument count，表示参数传入的个数
* argv[]：表示传入main的参数的指针，第一个参数argv[0]是程序运行时的路径名，从argv[1]开始才是传入的参数

通过程序验证一下：

```c
#include "stdio.h"

int main(int argc, char *argv[])
{
    int i;
    printf("argc is :%d\n", argc);
    for (i = 0; i < argc; i++) {
         printf("argv[%d] is :%s\n", i, argv[i]);
	 }

     return 0;
}

```

结果：



```c
gq@gq-virtual-machine:~/learn/code/c$ ./a first 4562 asdf 0x12
argc is :5
argv[0] is :./a
argv[1] is :first
argv[2] is :4562
argv[3] is :asdf
argv[4] is :0x12
```


参数可以在可执行文件之后直接加上。


## 10.20 C中static与C++中static的不同

C语言中：static用来修饰局部变量和全局变量，以及函数

C++中：static还可以用来修饰类的成员变量和函数，即静态成员和静态函数

C++中的静态成员可以在多个对象间进行通信，传递信息，即同一类中的static修饰的静态变量和成员函数一样，都是被各个对象公用的。

## 10.21 冒泡排序

借助一道题来练习排序算法：
![image-20201029082419238](../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/image-20201029082419238.png)

（从小到大）冒泡排序是每次比较相邻的两个元素大小，如果第一个比第二个大，交换位置，直到末尾。每次到达末尾之后当前元素作为新的末尾进行下一次冒泡。直到再也没有需要交换的。

图解：

![img](../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/bubbleSort.gif)

算法实现：

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

void Swap(int *a, int *b) {
    int k;
    k = *a;
    *a = *b;
    *b = k;
}

void BubbleSort(int *nums, int numsSize) {
    int i, j;
    int last_pos, is_sorted = 1;

    last_pos = numsSize-1;
    /* 冒泡排序 */
    for (i = last_pos; i > 0; i--) {  //以上次结束的位置为准
        is_sorted = 1; //每次开始前先假定有序
        for (j = 0; j < i; j++) {
            if (nums[j] > nums[j + 1]) { 
                Swap(&nums[j], &nums[j + 1]);
                
                last_pos = j;  //记录当前交换位置
                is_sorted = 0; 
            }
        }
        if (1 == is_sorted) break;//数组本来就有序，返回
    }
}

int* sortArray(int* nums, int numsSize, int* returnSize){
    int last_pos, is_sorted = 1;
    int *new = (int*)malloc(sizeof(int) * numsSize);
    *returnSize = numsSize;
    if (1 == numsSize) return nums;

    BubbleSort(nums, numsSize); //冒泡排序

    new = nums;      //栈里面处理更快，所以等排序完成之后再输出
    return new;
}
```

优化：

基于最基本的冒泡排序，做了以下几点优化：

* **若数组本来就有序或者排序几次后有序**，直接输出。在每次循环开始的时候`is_sorted = 1`假定数组有序，根据`is_sorted`来判断，若发生交换，则代表无序；若一次循环过后无交换则`1 == is_sorted`直接输出原数组

* **若数组局部有序**，则在下一次循环的时候无需对有序的部分再次进行排序，决定循环长度的是外层循环，所以外层循环的长度由上一次最后交换为位置决定：`for (i = last_pos; i > 0; i--)`，其中`last_pos`记录的是上一次循环最后的交换位置，在内存循环中更新

## 10.22 选择排序

选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧，在链表情况下使用比较稳定。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。重复第二步，直到所有元素均排序完毕。

**分为两部分，前半部分是已排序部分，后半部分是未排序部分，后面逐步==将未排序部分的最小值==找出依次放在已排序后面，==作为已排序部分新的最大值。==**

**选择排序的特点：**

①、**运行时间和输入无关**。为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息；
 ②、**数据移动是最小的**。每次交换都会改变两个数组元素的值，因此选择排序用了 N 次交换——交换次数和数组的大小是线性关系。（其他大部分排序算法的增长数量级都是线性对数或是平方级别的）

图解：
![img](../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/selectionSort.gif)

基础算法实现：

```c
void SelectionSort(int *nums, int numsSize) {
    int i, j, min; 
    
    for (i = 0; i < numsSize - 1; i++) {     //外层循环决定有序部分的长度
        min = i;
        for (j = i + 1; j < numsSize; j++) { //处理未排序部分
            if (nums[j] < nums[min]) {
                min = j;
            }           
        }
        Swap(&nums[min], &nums[i]);
    }
}
```

## 10.23 插入排序

插入排序和选择排序实现有些类似，都是分为已排序部分和未排序部分来看的，选择排序是每次选出未排序部分的最小值作为已排序部分的最大值。插入排序是在未排序部分中，依次排序，每次看一个元素，将此元素与已排序部分比较，直到找到在已排序部分中的位置。

插入排序，可以理解为插队式排序，从最后面依次寻找可插队的对象，对于比自己大的值，不敢在它面前插队，一旦遇到比自己小的值，就立刻插队。

图解：

![img](../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/insertionSort.gif)

算法实现：

```c
/* 插入排序 */
void InsertSort(int *num, int numsSize)
{
    int i, j, key;
    for (i = 1; i < numsSize; i++) {  //i表示 有序范围
        key = num[i];
        j = i - 1;
        while ( (j >= 0)&& (num[j] > key)) {  //顺序也有要求，从左到右先为1就直接退出
            num[j + 1] = num[j];              //排挤元素
            j--;
        }
        num[j + 1] = key;   //插入到适合的位置
    }
}

```

要注意，`while`判断中`(j >= 0)`的优先级要比后面的高，不然可能造成内存泄漏问题！！！

# 十一月

## 11.1 gcc输出文件类型

预编译

编译

汇编

链接

![image-20201101183232841](../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/image-20201101183232841.png)



**gdb：**

![image-20201101190647967](../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/image-20201101190647967.png)

## 11.2 符号中的空格

符号的中间一般不要加空格符、制表符、换行符，不然会引起歧义，比如`---`符号，空格的位置不同，运算结果也不同：

<img src="../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/image-20201103090102815.png" alt="image-20201103090102815" style="zoom:200%;" />

对于`a --- b`，编译器从左往右看，先读入一个`-`，再接着读入一个`-`，到这里编译器就认为这是一个自减运算符，再接着向右读入`-`，编译器认为`---`是先执行自减`–-`操作，然后执行减运算`-`的，所以`a --- b`在编译器看来就是`a -- - b`运算，得到结果为-1。

但是如果在第一个`-`之后就加上空格，即`a - -- b`，编译器就会认为第一个减号之后是程序员专门隔开的，所以先执行`–-b`再执行`a - b`，得到0。

再比如注释符`/**/`，如果遇到除数是指针指向的数据，可能会引起歧义：
![image-20201103091833060](../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/image-20201103091833060.png)![image-20201103092214363](../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/image-20201103092214363.png)

如果之间在`/`后面加上`*p`，就会让编译器认为这是注释`/**/`的开始，所以加上空格就会明确了。

**所以，以后在使用比较复杂的运算符组合的时候，切记要用空格来表达逻辑。**



## 11.3 单双引号的区别

简单来说，单引号`‘’`括起来的字符代表一个整数，就是该字符的ASCII码值；

双引号`“”`括起来的字符串代表的是一个指向无名数组起始字符的指针，该无名数组被双引号包括的字符串以及一个`\0`字符初始化。



## 11.4 函数类型转换符——显示调用指定地址函数

==如果我们要调出首地址为0xff位置的子函数，要想通过函数显式调用的方式，该怎么办？==

通过类型转换符来进行强制类型转换，最终的语句为：`(*void(*)() 0xff)();`

构造这种表达式的核心思想就是：按照使用的方式来声明，也就是先了解要干什么，然后再看怎么做。



**1.首先要明白C中变量的声明！！！**

C中的变量声明由两部分组成：

* 变量的数据类型，比如：int、float、char等等
* 声明符，相当于变量的表达式，对声明符求值会返回一个声明中给的的数据类型的结果，比如：`char *p`中的`*p`，对`*p`求值会返回一个char类型的数据

比如：

`char ff();`：声明符ff()的求值结果是char，代表ff()函数的返回值是一个char类型的数据，即声明了ff是一个返回值为char的函数；

`float *pf;`：声明符*pf的求值结果是一个float类型的数据，即声明了pf是一个指向float的指针；

`int *g();`：声明符`*g()`的求值结果是一个int型的数据，`()`优先级比`*`高，所以可以看作`*(g())`，其中g是一个函数，`(g())`代表函数的返回值，`*(g())`代表对函数返回值的地址求值，得到一个int数据，也就是函数返回的是一个int型的指针；`int *g()`也可以写成`int* g()`，表示函数g的返回值是一个int类型的指针；

`int (*h)()`：声明符中先执行`(*h)`，表示这是一个指针，后面`(*h)()`表示这个指针指向h函数，所以表示h是一个指向返回值是int的函数，即h是一个函数指针；

**2.已知函数指针，如何调用函数？**
比如`fp`是一个函数指针，那么调用这个函数的方法就是：`(*fp)();`，也可以简写为：`fp()`。

> 注意，不要把函数指针种指针的括号去掉，如果变为`*fp()`，就表示函数fp返回一个指针，`*`操作就是取得返回值的传递的值！

**3.由变量声明推出相应的 类型转换符**

了解声明之后，再看一下如何得到相应的类型转换符：把声明中的变量名和末尾的分号去掉，将剩余部分用括号封装起来就可以了。

比如我需要将一个指针强制转换为指向一个返回float的函数，首先写出此种函数的声明：

`float (*f)();`，然后去掉变量名和结尾分号，括号封装起来就是：`(float (*)())`，表示一个指向返回值是float型的函数的指针 的类型转换符。

言归正传，要调出首地址为0xff位置的子程序，就是要一个指针指向0xff位置的子程序！！！

具体方法是先写出这种指针的类型转换符，然后通过类型转换符声明一个指针指向0xff地址，过程如下：

* 先借助声明，一个指向函数的指针：`void (*f)();`
* 写出类型转换符，一个指向函数的指针的类型转换符：`(void (*)())`
* 调用类型转换符创建指针指向0xff的子程序：`(*(void (*)()) 0xff)() `

**4.调用函数**

调用函数的方式就是通过函数指针fp：`(*fp)();`，也就是`(*函数指针)`代表的是被调用函数的地址，这里是0xff，但是单纯的0xff是不行的，我们需要对0xff进行类型转换！！！

对0xff地址进行类型转换得到函数指针fp：`(void (*)())`，使用类型转换符转换0xff地址时，`fp`相当于`(void (*)()) 0xff`

套进去得到调用0xff函数的操作：`(*(void (*)()) 0xff)();`
## 11.5 Linux下静态库与共享库的特点

库中实际上就是已编译好的函数代码，可以被程序直接调用。

Linux下的库一般的位置在`/lib`或者`/usr/lib`中

**静态库**

静态库是复制拷贝到调用函数中的，函数运行的时候不再需要静态库，因为==静态库是在链接的时候加进去的==，所以当函数运行的时候，源库的改变对运行中的函数造成不影响。随之而来，当静态库升级之后，每一个调用静态库的程序都需要重新编译。

特点：

* 链接静态库的时候，会把库中的相关代码拷贝到可执行文件中
* 程序运行时不再需要静态库
* 程序运行时不需加载库，运行速度快
* 因为库中相关代码是拷贝到可执行文件中，所以占用了更多的磁盘和内存空间
* 静态库升级之后需要重新编译链接



**共享库**

特点：

* 共享库在链接的时候，仅仅是记录一下用到了哪个库中的哪个函数，并不复制库中相关代码
* 多个程序可以同时调用一个共享库
* 程序在运行的时候来加载共享库
* 程序体积变小，程序本身没有包含库中的代码
* 共享库升级之后，无需重新编译程序

## 11.6 命名冲突与static

首先要明白static的作用是：将作用域限制在一个源文件中，对于局部来说相当于变成了全局，对于全局来说，相当于是限制在这个源文件中。

static还可以用来修饰函数，所以我们可以在多个文件中定义函数为同一个名字，前提是这些函数被定义为static。

为了避免可能出现的命名冲突，如果一个函数仅仅在这个源文件中被其他函数调用，我们应该将此函数声明为static。

## 11.7 Linux中添加新用户

```shell
adduser new_user           #创建一个用户名为new_user的新用户
usermod -G sudo new_user   #将新用户添加到sudo组中
su - new_user              #切换到新用户下
```



## 11.8 putchar()函数

putchar函数原型为：

```c
int putchar(int c);
```

输出一个字符，注意参数虽然是一个字符，但是函数原型里面确却是int，这是因为字符在编译器看来就是一个对应ASCII值的int数据。


## 11.9 getchar()函数

![image-20201109082917307](../../../%25E8%25BD%25AF%25E4%25BB%25B6%25E7%25AE%25A1%25E5%25AE%25B6/Typora/%25E5%259B%25BE%25E7%2589%2587%25E5%25BA%2593/image-20201109082917307.png)

一个字符输入函数，返回的应该是读取到的字符，可是这里的返回值是int，原因有二：
1.char是有符号的，ASCII的范围可能使char

2.unsigned char虽然可以接收传回的字符，但是出错或者结束键盘输入的时候，返回的是-1，unsigned char无法读取

所以使用int来接收输入的字符，int数据也可以用`%c %d %x`来格式化输出。



## 11.10 二维数组求行列大小

求二维数组得行数、列数。

通过sizeof来求：

```c
char str[][5];
int n, m;
n = sizeof(str) / sizeof(str[0]);   //行
m = sizeof(str) / sizeof(char);     //列
```



## 11.11 Linux下的段错误（Segmentation fault）

段错误是指：访问了系统分配给程序的内存空间之外起的内存空间，比如：

* 访问不存在的地址
* 访问受系统保护的地址
* 访问了只读内存地址
* 内存访问越界

要注意的：

* 使用strcpy, strcat, sprintf, strcmp, strcasecmp等字符串操作函数，将目标字符串读/写爆。应该使用strncpy, strlcpy, strncat, strlcat, snprintf, strncmp, strncasecmp等函数防止读写越界。
* 初始化指针后，尽量使用malloc分配一个内存空间，或者在初始化的时候就分配，以防内存访问越界。

* puts()函数时中参数为一个字符时，会触发越界访问，因为字符只是一个值，没有结束符‘\0’，字符串处理函数会找不到结束符，就一直在内存中找下去，造成内存访问越界。相应的字符串操作函数更应该注意！！！
* 有时候可能会访问只读的内存，比如试图修改一个字符串常量的内容，字符串常量编译后放在`.rodata`中，是只读的
* 访问受系统保护的地址，最常见的就是给指针0地址，然后去访问。
* 访问了不存在的内存，比如引用了一个空指针
* 还有，涉及到字符串处理的时候特别容易内存访问越界，因为大多数字符串相关的处理操作都是以结束符`\0`作为结束的标志的！

>1 使用非法的内存地址（指针），包括使用未经初始化及已经释放的指针、不存在的地址、受系统保护的地址，只读的地址等，这一类也是最常见和最好解决的段错误问题，使用GDB print一下即可知道原因。
>
>2 内存读/写越界。包括数组访问越界，或在使用一些写内存的函数时，长度指定不正确或者这些函数本身不能指定长度，典型的函数有strcpy(strncpy)，sprintf(snprint)等等。
>
>3 对于C++对象，应该通过相应类的接口来去内存进行操作，禁止通过其返回的指针对内存进行写操作，典型的如string类的c_str()接口，如果你强制往其返回的指针进行写操作肯定会段错误的，因为其返回的地址是只读的。
>
>4 函数不要返回其中局部对象的引用或地址，当函数返回时，函数栈弹出，局部对象的地址将失效，改写或读这些地址都会造成未知的后果。
>
>5 避免在栈中定义过大的数组，否则可能导致进程的栈空间不足，此时也会出现段错误，同样的，在创建进程/线程时如果不知道此线程/进程最大需要多少栈空间时最好不要在代码中指定栈大小，应该使用系统默认的，这样问题比较好查，ulimit一下即可知道。这类问题也是为什么我的程序在其他平台跑得好好的，为什么一移植到这个平台就段错误了。
>
>6 操作系统的相关限制，如：进程可以分配的最大内存，进程可以打开的最大文件描述符个数等，在Linux下这些需要通过ulimit、setrlimit、sysctl等来解除相关的限制，这类段错误问题在系统移植中也经常发现，以前我们移植Linux的程序到VxWorks下时经常遇到（VxWorks要改内核配置来解决）。
>
>7 多线程的程序，涉及到多个线程同时操作一块内存时必须进行互斥，否则内存中的内容将不可预料。
>
>8 在多线程环境下使用非线程安全的函数调用，例如 strerror 函数等。
>
>9 在有信号的环境中，使用不可重入函数调用，而这些函数内部会读或写某片内存区，当信号中断时，内存写操作将被打断，而下次进入时将无法避免地出错。
>
>10 跨进程传递某个地址，传递的都是经过映射的虚拟地址，对另外一个进程是不通用的。
>
>11 某些有特殊要求的系统调用，例如epool_wait，正常情况下使用close关闭一个套接字后，epool会不再返回这个socket上的事件，但是如果你使用dup或dup2操作，将导致epool无法进行移除操作，此时再进行读写操作肯定是段错误的。





参考：https://www.cnblogs.com/zl-graduate/p/5735288.html

https://blog.csdn.net/u010150046/article/details/77775114


## 11.12 大段小段问题

大端小端的讨论、存储都是以字节为单位，大小端主要由CPU决定，与编译器、OS没有关系。

CPU对操作数的存放方式分为大端和小段：

* 小端：高地址存放低位
* 大端：高地址存放高位

（以高地址存放的数据来判断，高位就是大端、低位就是小端）

![image-20201112072033610](../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/image-20201112072033610.png)

大多数ARM处理器采用大端模式，PowerPC采用大端模式，网络字节序采用小端模式。

可以通过联合体来测试当前CPU是大端还是小端：

```c
#include <stdio.h>

int main(int argc, char* argv[])
{
        int i, j, k;
        union test_union{
                char ch[4];
                int  n;
        }test;
        test.n = 0X12345678;

        printf("%x\n", test.n);
        printf("%x %x %x %X\n", test.ch[0], test.ch[1], test.ch[2], test.ch[3]);

        return 0;
}
```

执行结果如下：

<img src="../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/image-20201112073936024.png" alt="image-20201112073936024" style="zoom:200%;" />

可以看出，当前CPU的执行结果中，高地址存放的是高位，所以是大端模式。

## 11.13 用递归实现斐波那契数列

```c
#include <stdio.h>

int Recursive(int n);

int main (int argc, const char* argv[])
{

        int n, i;
        puts("input n:");
        scanf("%d", &n);

        for (i = 1; i <= n; i++) {
                printf("%d  ", Recursive(i));
        }
        puts("");
        return 0;
}

int Recursive(int n)
{
        if ((n == 1) || (n == 2))  //终止条件，也是已知条件
                return 1;
        return Recursive(n - 1) + Recursive(n - 2); //推导条件
}
```



## 11.14 利用指针函数实现strcat的功能

strcat是字符串追加函数。

```c
#include <stdio.h>

char* Strcat (char *dest, const char *str);

int main (int argc, const char* argv[])
{
        char dest[50], str[50];

        puts("input *dest:");
        gets(dest);
        puts("input *str:");
        gets(str);

        puts("strcat(dest, str) is:");
        puts(Strcat(dest, str));

        return 0;
}



char* Strcat (char *dest, const char *str)
{
        char *p;
        int i = 0, n = 0;

        p = dest;
        while (p[n++] != '\0'); //结束时p指向'\0'，dest的长度是n - 1
        n--;
        for (i = 0; str[i] != '\0'; i++) {
                p[n + i] = str[i];
        }
        p[n + i] = '\0';

        return p;

}
```



##  11.15 C语言中的符号重载

之前了解到重载，是在C++中，有函数的重载、运算符的重载。其实C语言中也有符号的重载如下：
**static：**

* 作用于变量时，表示变量的值在各个调用间保持连续性
* 作用于函数时，表示该函数只对本文件可见

**extern：**

* 作用于变量时，表示在其他地方已定义
* 作用于函数时，表示全局可见（函数缺省全局可见）

**void：**

* 作为函数返回值类型时，表示不反悔任何值
* 在指针的声明中，表示通用的指针类型
* 位于参数列表中时，表示没有参数

***：**

* 乘法运算符
* 作用于指针时，表示引用
* 在声明中，表示指针类型

**&：**

* 取地址操作符
* 位的AND运算操作符

**（）：**

* 在函数定义中，包围着形参列表
* 表示调用一个函数
* 改变表达式的运算次序，先执行括号里
* 用于强制类型转换
* 定义带参数的宏
* 包围sizeof的操作数

越学感觉知识越相似！！！


## 11.16 Linux 数字权限使用

Linux中对文件的权限有严格的控制，想要对某个文件进行相关的操作时，要有相应的权限才可以。

一般权限包括：读r、写w、执行x

Linux权限的使用者分类有三种：

* u：文件拥有用户
* g：同一组的用户
* o：其他组的用户

如果其他组的用户想要拥有对文件进行某一操作的权限，可以将该用户加入具备权限的组，所以一个用户可以同时归属多个组。一般使用`chmod`命令来对文件的权限进行修改设置。

权限可以用相应的数字来表示，数字4、2、1分别代表读、写、执行权限，所以对文件的权限描述可以通过4、2、1三个数字的相加来表示（三个数字的组合都是唯一的）`7=4+2+1  6=4+2 5=4+1 3=2+1`。

而且一个文件的权限是针对三个

比如：

```shell
chmod 700 test.c   #-rwx------ u：读、写、执行  g：无权限  o： 无权限   
chmod 740 test.c   #-rwxr----- u：读、写、执行  g：只读  o： 无权限  
chmod 761 test.c   #-rwxrw---x u：读、写、执行  g：读、写  o： 只执行  
```

常见权限形式：

```shell
-rw------- (600)      #只有拥有者有读写权限。
-rw-r--r-- (644)      #只有拥有者有读写权限；而属组用户和其他用户只有读权限。
-rwx------ (700)      #只有拥有者有读、写、执行权限。
-rwxr-xr-x (755)      #拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。
-rwx--x--x (711)      #拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。
-rw-rw-rw- (666)      #所有用户都有文件读、写权限。
-rwxrwxrwx (777)      #所有用户都有读、写、执行权限。
```



## 11.17 二维数组的指针运算

 int a [ 5 ] [ 4 ], ( * p)[4]=a;，数组a的首地址为100，* (p+2)+3等于 （ ）

* A  116
* B  118
* C  144
* D  122

答案是：C

对于`int a[5][4]`，a相当于一个二级指针，`a`是一个指针数组，数组中的每一个元素`a[0] a[1] a[2]`都是指针；`a[0]`是一个指向数组的指针，数组中有4个int数据。

对于`int (*p)[4]=a`，p是一个指针数组，数组中有4个int数据，即p和a在指向的对象上是一致的，然后`p=a`，a的首地址为100，代表b中存储的值就是100。

`*(p + 2)`相当于`a[2]`，还是一个指针，相对于a来讲移动了8个int的内存地址，然后又`*(p + 2) + 3`，又相当于移动了3个int的内存地址，所以一共移动了11个int的内存地址，即44Byte，所以`*(p + 2) + 3`的值为144，本质上还是地址。






## 11.18 Make file 变量

makefile中变量分为三种：

* 用户自定义变量
* 预定义变量
* 自动变量



#### 自定义变量的定义和引用

变量是用来代替如下类型的文本字符串：

* 系列文件的名字
* 传递给编译器的参数
* 需要一些的程序
* 需要查找源代码的目录
* 需要输出信息的其他目录
* 其他事情

定义变量的方法为：

* 递归展开：VAR=var
* 简单扩展：VAR :=var

要注意的是：递归展开在展开的时候可以将内嵌的变量全部展开，但是如果在变量后面追加内容，可能在扩展的过程中导致无穷循环。所以一般情况下使用简单扩展比较好。

变量的使用：
于shell中一样，要引用变量的值，需要符号`$`，以`$(VAR)`的形式来引用变量，只有在变量定义的时候不需要`$`，引用变量相当于C语言中的宏定义。

若要表示`$`本身，则`$$`即可

例如：

```makefile
OBJ = main.o hello.o bye.o
CC = gcc
CFLAGES = -Wall -O -g
create: $(OBJ)
        $(CC) $(CFLAGES) $(OBJ) -o a.out
main.o: main.c
        $(CC) $(CFLAGES) -c main.c -o main.o
hello.o: hello.c
        $(CC) $(CFLAGES) -c hello.c -o hello.o
bye.o: bye.c
        $(CC) $(CFLAGES) -c bye.c -o bye.o

clean:
        rm *.o

```

> 变量在定义的时候，直接=即可，变量在引用的时候必须加上`$`

可以通过`+=`运算为变量添加新的值

#### 预定义变量

![image-20201118091530191](https://i.loli.net/2020/11/18/sQi2ox3cI4jLlXt.png)

 ![image-20201118091616415](https://i.loli.net/2020/11/18/4YLZAhicok5uxQ3.png)



#### 自动变量

![image-20201118092302979](https://i.loli.net/2020/11/18/NlZS5OMRgvVG7Dk.png)

修改后的Makefile如下：

```makefile
OBJ  := main.o hello.o bye.o
CC  := gcc
CFLAGES := -Wall -O -g
create: $(OBJ)
        $(CC) $(CFLAGES) $(OBJ) -o a.out
main.o: main.c
        $(CC) $(CFLAGES) -c $< -o $@
hello.o: hello.c
        $(CC) $(CFLAGES) -c $< -o $@
bye.o: bye.c
        $(CC) $(CFLAGES) -c $< -o $@

clean:
        rm *.o

```



#### 环境变量

![image-20201118092338409](https://i.loli.net/2020/11/18/5jUrAcuyB9atTdR.png)



## 11.19 Linux修改主机名

有时Linux中的主机名太长了，搞得我们命令行都不好看，所以可以通过命令行来修改主机名。

**查看主机信息**

通过`hostnamectl`来产看主机的信息：
![image-20201119191913937](https://i.loli.net/2020/11/19/rwvzUng2FC3KmDx.png)

**修改主机名称**

还是通过`hostnamectl`命令来修改主机名，可以通过`man hostnamectl `来查看有关的命令：

![image-20201119192126824](https://i.loli.net/2020/11/19/TqAwnedQ4V7Y1yh.png)

通过如下命令即可修改主机名：

```shell
hostnamectl set-hostname <new hostname>
```

参考：https://linux.cn/article-10651-1.html

## 11.20 顺序表的创建、删除、插入、查找

### 创建顺序表

对于线性表的创建，要注意以下几点：

* 线性表内存的分配，这里采用动态内存分配malloc
* 使用malloc的时候记得要检查申请空间是否成功
* 顺序表的初始化，采用memset()进行整个顺序表的初始化，因为malloc申请的空间是不会自动初始化的，所以先统一初始化一下
* 然后对顺序表中单独的有特殊需求的成员初始化，比如上面将顺序表元素都初始化为0，还要单独对last初始化为-1
* 要注意sqlist于sqlink的区别，sizeof(sqlist)是顺序表的大小，sizeof(sqlink)是指针的大小4Byte

代码如下：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "sqlist.h"

sqlink link_create(void)
{
    sqlink L = (sqlink)malloc(sizeof(sqlist));
    if (L == NULL) {
        puts("err!");
        return NULL;
    }
    memset(L, 0, sizeof(sqlist));
    L->last = -1;
    
    return L;
}
```



### 插入元素

对于线性表的插入，要明确插入的位置以及插入的数据，插入元素的主要步骤如下：

* 先检查线性表是否满了
* 再检查位置是否合法 [0, last+1]
* 移动线性表元素
* 更新插入位置的元素，同时last计数++

验证插入函数的时候，在特殊位置也要验证，比如两侧、中间、越界。

还有，last表示顺序表中最后一个元素的下标，所以是从零开始。

代码如下：

```c
int link_insert(sqlink L, data_t val, int post)
{
        int i;
        if (L == NULL) {
                puts("sqlink L is NULL!");
                return 0;
        } if (L->last == N-1) {
                puts("sqlink is full!");
                return 0;
        } if (post < 0 || post > L->last) {
                puts("insert post is err!");
                return 0;
        }

        for (i = L->last; i >= post; i--) {
                L->data[i + 1] = L->data[i];
        }
        L->data[post] = val;
        L->last++;

        return 1;
}
```



### 查找元素

查找元素就是遍历顺序表，找出第一个符合条件的元素的位置，返回，代码如下：

```c
int link_insert(sqlink L, data_t val, int post)
{
        int i;
        printf("%d\n", L->last);
        if (L == NULL) {
                puts("sqlink L is NULL!");
                return 0;
        } if (L->last == N-1) {
                puts("sqlink is full!");
                return 0;
        } if (post < 0 || post > L->last) {
                puts("insert post is err!");
                return 0;
        }

        for (i = L->last; i >= post; i--) {
                L->data[i + 1] = L->data[i];
        }
        L->data[post] = val;
        L->last++;

        return 1;
}
```



### 删除元素

要注意，删除的时候同样也要对范围进行检查，从后向前移动，最后还要更新位置。

代码如下：

```c
int link_delete(sqlink L, int post)
{
        int i;
        if (L == NULL) {
                puts("sqlink is NULL!");
                return 0;
        } if (post < 0 || post > L->last) {
                puts("post is err!");
                return 0;
        }

        for (i = post; i < L->last; i++) {
                L->data[i] = L->data[i + 1];
        }                        
        L->last--;
        return 1;
}

```



## 11.21 vim 替换字符

小技巧：

> vim中的`Ctr + S`是锁定屏幕，`Ctr + Q`是解锁屏幕

字符串替换，是在命令模式下输入的，形如：

```c
:s/abc/ABC
```

这就是将光标所在行遇到的第一个“abc”替换为“ABC”，注意，单纯的替换命令s只是替换光标所在行的第一个遇到的字符串。

如果想把光标所在行的所有“abc”字符串都替换掉，需要在命令后面再加一个g:

```c
:s/abc/ABC/g
```

如果着还满足不了需求，可以在全文范围内进行替换，需要在命令前加上范围：

```c
:x, y s/abc/ABC/g
```

这下，就是从第x行到第y行，将所有的“abc”替换为“ABC”，当然也可以使用`$`来表示最后一行。

如果还不行，我们要一次性在全文范围内进行替换，那就加上`%`来表示全文范围：

```c
:%s/abc/ABC
```



## 11.21 vim 替换字符

小技巧：

> vim中的`Ctr + S`是锁定屏幕，`Ctr + Q`是解锁屏幕

字符串替换，是在命令模式下输入的，形如：

```c
:s/abc/ABC
```

这就是将光标所在行遇到的第一个“abc”替换为“ABC”，注意，单纯的替换命令s只是替换光标所在行的第一个遇到的字符串。

如果想把光标所在行的所有“abc”字符串都替换掉，需要在命令后面再加一个g:

```c
:s/abc/ABC/g
```

如果着还满足不了需求，可以在全文范围内进行替换，需要在命令前加上范围：

```c
:x, y s/abc/ABC/g
```

这下，就是从第x行到第y行，将所有的“abc”替换为“ABC”，当然也可以使用`$`来表示最后一行。

如果还不行，我们要一次性在全文范围内进行替换，那就加上`%`来表示全文范围：

```c
:%s/abc/ABC
```



## 11.22 vim 配置

Vim 的全局配置一般在`/etc/vim/vimrc`或者`/etc/vimrc`，对所有用户生效。用户个人的配置在`~/.vimrc`。

在用户主目录下配置`.vimrc`即可。

配置后有如下功能：1.按F5可以直接编译并执行C、C++、java代码以及执行shell脚本，按“F8”可进行C、C++代码的调试

2.自动插入文件头 ，新建C、C++源文件时自动插入表头：包括文件名、作者、联系方式、建立时间等，读者可根据需求自行更改

3.映射“Ctrl + A”为全选并复制快捷键，方便复制代码

4.按“F2”可以直接消除代码中的空行

5.“F3”可列出当前目录文件，打开树状文件目录

\6. 支持鼠标选择、方向键移动

\7. 代码高亮，自动缩进，显示行号，显示状态行

8.按“Ctrl + P”可自动补全

9.[]、{}、()、""、' '等都自动补全

10.其他功能读者可以研究以下文件

```shell
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" 显示相关  

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

"set shortmess=atI   " 启动的时候不显示那个援助乌干达儿童的提示  

"winpos 5 5          " 设定窗口位置  

"set lines=40 columns=155    " 设定窗口大小  

"set nu              " 显示行号  

set go=             " 不要图形按钮  

"color asmanian2     " 设置背景主题  

set guifont=Courier_New:h10:cANSI   " 设置字体  

"syntax on           " 语法高亮  

autocmd InsertLeave * se nocul  " 用浅色高亮当前行  

autocmd InsertEnter * se cul    " 用浅色高亮当前行  

"set ruler           " 显示标尺  

set showcmd         " 输入的命令显示出来，看的清楚些  

"set cmdheight=1     " 命令行（在状态行下）的高度，设置为1  

"set whichwrap+=<,>,h,l   " 允许backspace和光标键跨越行边界(不建议)  

"set scrolloff=3     " 光标移动到buffer的顶部和底部时保持3行距离  

set novisualbell    " 不要闪烁(不明白)  

set statusline=%F%m%r%h%w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\"%d/%m/%y\ -\ %H:%M\")}   "状态行显示的内容  

set laststatus=1    " 启动显示状态行(1),总是显示状态行(2)  

set foldenable      " 允许折叠  

set foldmethod=manual   " 手动折叠  

"set background=dark "背景使用黑色 

set nocompatible  "去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限  

" 显示中文帮助

if version >= 603

    set helplang=cn

    set encoding=utf-8

endif

" 设置配色方案

"colorscheme murphy

"字体 

"if (has("gui_running")) 

"   set guifont=Bitstream\ Vera\ Sans\ Mono\ 10 

"endif 


 
set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936

set termencoding=utf-8

set encoding=utf-8

set fileencodings=ucs-bom,utf-8,cp936

set fileencoding=utf-8



"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

"""""新文件标题""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

"新建.c,.h,.sh,.java文件，自动插入文件头 

autocmd BufNewFile *.cpp,*.[ch],*.sh,*.java exec ":call SetTitle()" 

""定义函数SetTitle，自动插入文件头 

func SetTitle() 

    "如果文件类型为.sh文件 

    if &filetype == 'sh' 

        call setline(1,"\#########################################################################") 

        call append(line("."), "\# File Name: ".expand("%")) 

        call append(line(".")+1, "\# Author: ma6174") 

        call append(line(".")+2, "\# mail: ma6174@163.com") 

        call append(line(".")+3, "\# Created Time: ".strftime("%c")) 

        call append(line(".")+4, "\#########################################################################") 

        call append(line(".")+5, "\#!/bin/bash") 

        call append(line(".")+6, "") 

    else 

        call setline(1, "/*************************************************************************") 

        call append(line("."), "    > File Name: ".expand("%")) 

        call append(line(".")+1, "    > Author: ma6174") 

        call append(line(".")+2, "    > Mail: ma6174@163.com ") 

        call append(line(".")+3, "    > Created Time: ".strftime("%c")) 

        call append(line(".")+4, " ************************************************************************/") 

        call append(line(".")+5, "")

    endif

    if &filetype == 'cpp'

        call append(line(".")+6, "#include<iostream>")

        call append(line(".")+7, "using namespace std;")

        call append(line(".")+8, "")

    endif

    if &filetype == 'c'

        call append(line(".")+6, "#include<stdio.h>")

        call append(line(".")+7, "")

    endif

    "新建文件后，自动定位到文件末尾

    autocmd BufNewFile * normal G

endfunc 

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

"键盘命令

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""



nmap <leader>w :w!<cr>

nmap <leader>f :find<cr>



" 映射全选+复制 ctrl+a

map <C-A> ggVGY

map! <C-A> <Esc>ggVGY

map <F12> gg=G

" 选中状态下 Ctrl+c 复制

vmap <C-c> "+y

"去空行  

nnoremap <F2> :g/^\s*$/d<CR> 

"比较文件  

nnoremap <C-F2> :vert diffsplit 

"新建标签  

map <M-F2> :tabnew<CR>  

"列出当前目录文件  

map <F3> :tabnew .<CR>  

"打开树状文件目录  

map <C-F3> \be  

"C，C++ 按F5编译运行

map <F5> :call CompileRunGcc()<CR>

func! CompileRunGcc()

    exec "w"

    if &filetype == 'c'

        exec "!g++ % -o %<"

        exec "! ./%<"

    elseif &filetype == 'cpp'

        exec "!g++ % -o %<"

        exec "! ./%<"

    elseif &filetype == 'java' 

        exec "!javac %" 

        exec "!java %<"

    elseif &filetype == 'sh'

        :!./%

    endif

endfunc

"C,C++的调试

map <F8> :call Rungdb()<CR>

func! Rungdb()

    exec "w"

    exec "!g++ % -g -o %<"

    exec "!gdb ./%<"

endfunc

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""实用设置

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" 设置当文件被改动时自动载入

set autoread

" quickfix模式

autocmd FileType c,cpp map <buffer> <leader><space> :w<cr>:make<cr>

"代码补全 

set completeopt=preview,menu 

"允许插件  

filetype plugin on

"共享剪贴板  

set clipboard+=unnamed 

"从不备份  

set nobackup

"make 运行

:set makeprg=g++\ -Wall\ \ %

"自动保存

set autowrite

set ruler                   " 打开状态栏标尺

set cursorline              " 突出显示当前行

set magic                   " 设置魔术

set guioptions-=T           " 隐藏工具栏

set guioptions-=m           " 隐藏菜单栏

"set statusline=\ %<%F[%1*%M%*%n%R%H]%=\ %y\ %0(%{&fileformat}\ %{&encoding}\ %c:%l/%L%)\

" 设置在状态行显示的信息

set foldcolumn=0

set foldmethod=indent 

set foldlevel=3 

set foldenable              " 开始折叠

" 不要使用vi的键盘模式，而是vim自己的

set nocompatible

" 语法高亮

set syntax=on

" 去掉输入错误的提示声音

set noeb

" 在处理未保存或只读文件的时候，弹出确认

set confirm

" 自动缩进

set autoindent

set cindent

" Tab键的宽度

set tabstop=4

" 统一缩进为4

set softtabstop=4

set shiftwidth=4

" 不要用空格代替制表符

set noexpandtab

" 在行和段开始处使用制表符

set smarttab

" 显示行号

set number

" 历史记录数

set history=1000

"禁止生成临时文件

set nobackup

set noswapfile

"搜索忽略大小写

set ignorecase

"搜索逐字符高亮

set hlsearch

set incsearch

"行内替换

set gdefault

"编码设置

set enc=utf-8

set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936

"语言设置

set langmenu=zh_CN.UTF-8

set helplang=cn

" 我的状态行显示的内容（包括文件类型和解码）

"set statusline=%F%m%r%h%w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\"%d/%m/%y\ -\ %H:%M\")}

"set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%]

" 总是显示状态行

set laststatus=2

" 命令行（在状态行下）的高度，默认为1，这里是2

set cmdheight=2

" 侦测文件类型

filetype on

" 载入文件类型插件

filetype plugin on

" 为特定文件类型载入相关缩进文件

filetype indent on

" 保存全局变量

set viminfo+=!

" 带有如下符号的单词不要被换行分割

set iskeyword+=_,$,@,%,#,-

" 字符间插入的像素行数目

set linespace=0

" 增强模式中的命令行自动完成操作

set wildmenu

" 使回格键（backspace）正常处理indent, eol, start等

set backspace=2

" 允许backspace和光标键跨越行边界

set whichwrap+=<,>,h,l

" 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）

set mouse=a

set selection=exclusive

set selectmode=mouse,key

" 通过使用: commands命令，告诉我们文件的哪一行被改变过

set report=0

" 在被分割的窗口间显示空白，便于阅读

set fillchars=vert:\ ,stl:\ ,stlnc:\

" 高亮显示匹配的括号

set showmatch

" 匹配括号高亮的时间（单位是十分之一秒）

set matchtime=1

" 光标移动到buffer的顶部和底部时保持3行距离

set scrolloff=3

" 为C程序提供自动缩进

set smartindent

" 高亮显示普通txt文件（需要txt.vim脚本）

au BufRead,BufNewFile *  setfiletype txt

"自动补全

:inoremap ( ()<ESC>i

:inoremap ) <c-r>=ClosePair(')')<CR>

:inoremap { {<CR>}<ESC>O

:inoremap } <c-r>=ClosePair('}')<CR>

:inoremap [ []<ESC>i

:inoremap ] <c-r>=ClosePair(']')<CR>

:inoremap " ""<ESC>i

:inoremap ' ''<ESC>i

function! ClosePair(char)

    if getline('.')[col('.') - 1] == a:char

        return "\<Right>"

    else

        return a:char

    endif

endfunction

filetype plugin indent on 

"打开文件类型检测, 加了这句才可以用智能补全

set completeopt=longest,menu

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" CTags的设定  

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let Tlist_Sort_Type = "name"    " 按照名称排序  

let Tlist_Use_Right_Window = 1  " 在右侧显示窗口  

let Tlist_Compart_Format = 1    " 压缩方式  

let Tlist_Exist_OnlyWindow = 1  " 如果只有一个buffer，kill窗口也kill掉buffer  

let Tlist_File_Fold_Auto_Close = 0  " 不要关闭其他文件的tags  

let Tlist_Enable_Fold_Column = 0    " 不要显示折叠树  

autocmd FileType java set tags+=D:\tools\java\tags  

"autocmd FileType h,cpp,cc,c set tags+=D:\tools\cpp\tags  

"let Tlist_Show_One_File=1            "不同时显示多个文件的tag，只显示当前文件的

"设置tags  

set tags=tags  

"set autochdir 



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

"其他东东

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

"默认打开Taglist 

let Tlist_Auto_Open=1 

"""""""""""""""""""""""""""""" 

" Tag list (ctags) 

"""""""""""""""""""""""""""""""" 

let Tlist_Ctags_Cmd = '/usr/bin/ctags' 

let Tlist_Show_One_File = 1 "不同时显示多个文件的tag，只显示当前文件的 

let Tlist_Exit_OnlyWindow = 1 "如果taglist窗口是最后一个窗口，则退出vim 

let Tlist_Use_Right_Window = 1 "在右侧窗口中显示taglist窗口

" minibufexpl插件的一般设置

let g:miniBufExplMapWindowNavVim = 1

let g:miniBufExplMapWindowNavArrows = 1

let g:miniBufExplMapCTabSwitchBufs = 1
let g:miniBufExplModSelTarget = 1
```





## 11.23 Xshell中配置.vimrc后无法使用Ctr+Insert复制的解决

　在用户目录编辑.vimrc文件不存在则创建，vi的三种模式:命令模式，插入模式，可视模式，鼠标可以启动于各种模式中，所以配置文件中的set mouse=a启动了所有模式，这样就屏蔽了鼠标右健功能，set mouse=c模式开启复制黏贴。

这涉及到

vim中鼠标的使用，在命令行通过`set mouse=xxx`来设置，其中`xxx`九十四命令参数，如下：

```c
    n    普通模式
    v    可视模式
    i    插入模式
    c    命令行模式
    h    在帮助文件里，以上所有的模式
    a    以上所有的模式
    r    跳过 |hit-enter| 提示
    A    在可视模式下自动选择
```




