
# 八月

## 8.23 resister关键字

当对一个变量频繁被读写时，需要反复访问内存，从而花费大量的存取时间。为此，C语言提供了一种变量，即寄存器变量。这种变量存放在CPU的寄存器中，使用时，不需要访问内存，而直接从寄存器中读写，从而提高效率。寄存器变量的说明符是register。对于循环次数较多的循环控制变量及循环体内反复使用的变量均可定义为寄存器变量，而循环计数是应用寄存器变量的最好候选者。



(1) 只有局部自动变量和形参才可以定义为寄存器变量。因为寄存器变量属于动态存储方式，凡需要采用静态存储方式的量都不能定义为寄存器变量，包括：模块间全局变量、模块内全局变量、局部static变量;



(2) register是一个"建议"型关键字，意指程序建议该变量放在寄存器中，但最终该变量可能因为条件不满足并未成为寄存器变量，而是被放在了存储器中，但编译器中并不报错(在C++语言中有另一个"建议"型关键字：inline)。





## 8.24 数组的[]原理

分析下列代码的输出结果：

```c
int array[10]={0};
0[array] = 1;
printf("%d",(-5)[array+5]);
```

结果是输出：1

因为==array[2]可以看作`*(array+2)`==，所以`(-5)[array+5]`就相当于`*(-5+array+5)`，也就是`*(array+0)`。

所以，尽量使用指针代替数组， ==指针方法的优点是，array的地址每次装入地址p后，在每次循环中只需对p增量操作。在数组索引方法中，每次循环中都必须进行基于t值求数组下标的复杂运算 。==





##  8.25 static作用

Static是C的一个关键字，根据其修饰的对象属性不同可以分为两种用途：

1.修饰存储类型，使之成为静态存储类型

2.修饰链接属性，使之成为内部链接属性

==静态存储类型：==

当修饰在函数内部定义的局部变量时，这个局部变量就存储在函数的内存静态区，函数运行结束后也不会销毁这个局部变量的值，**函数下次运行的时候依然可以使用上次运行后的变量的值**。

当修饰全局变量的时候，此时的全局变量就是静态全局变量，**该变量的作用域只能够限制在定义该变量的文件中，而且其他文件不能够通过extern关键字来引用**。



==内部链接属性：==

 静态函数只能在声明它的源文件中使用 。



例子：




## 8.26 字符串结束问题

判断如下程序输出的值：

```c
char c[][8]={"apple","orange","banana"};
  
printf("%d,",sizeof(c));
printf("%d",strlen(c));
```

这涉及到sizeof和strlen的区别：

* sizeof是判断类型占用的大小，取决于数据类型
* strlen是判断字符串长度的，遇到字符串结束符‘\0’的时候就结束了，所以结果取决于‘\0’的位置



所以对于

```c
char c[][8]={"apple","orange","banana"};
```

三个元素，每个元素的空间是8个字节，所以sizeof(c)输出的是8*3=24

然鹅，对于strlen，在第一个字符串元素“apple”的末尾就遇到了‘\0’，所以在第一个字符串元素结束后就会结束判断，所以最终结果是apple这五个字符的长度，即5

图示：
![1598450805538](../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/1598450805538.png)





## 8.27 const用法

const具有左结合性，即通常：const + 修饰变量



对于const的用法，程序如下：

```c
int tmp = 66;
int *const age = &tmp;
int newage = 23;
```

执行的语句如下：

```c
*age=newage;
age = &newage;
```

问题：判断哪个语句是正确的，为什么？

分析：

第一条代码：创建一个int型变量tmp，并且初始化66

第二条代码：创建一个int型指针age，指向tmp变量，age中的值就是tmp的地址，==const具有左结合性，所以const修饰的是age，即指针的指向不变，始终指向tmp的地址==

第三条代码：创建一个int型变量newage，并且初始化23



第一条语句：*age=newage; 表示改变age指向地址中的值为23（星号为取地址符），但是指针的指向不变

第二条语句：age = &newage; 表示改变age的指向，使age指向newage变量的地址，由于const修饰了age，也就是指针的指向，所以指向不可改变，==第二条指令错误！！！==



> 关于指针的要点分析：
>
> ```c
> int * p;
> ```
>
> 我们要明白定义一个指针变量时，`* 和 p`分别代表这什么
>
> `*`是取值运算符，所以`*p`代表指针指向的地址中的值；
>
> `p`代表指针指向的地址；
>
> `&p`代表指针的地址；
>
> `*&p`代表指针地址中的值，也就是指针指向的地址



## 8.28 野指针

下列代码的运行结果是什么：

```c
int *p;
int a = 8;
*p = a;
printf("%d",*p);
```

运行结果如下：

<img src="../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/1598577426706.png" alt="1598577426706" style="zoom:200%;" />

> 错误提示：Segmentation fault ( core dumped )多为内存操作不当造成的，比如空指针、野指针的读写操作，数组的越界访问，破坏常量等。避免这个问题的最好方法就是在指针声明后对其进行初始化NULL操作。



分析：

虽然声明了p指针，但是没有说明p指向哪个内存位置，所以p就是一个野指针，对野指针执行`*p=a`后就会报错。

野指针形成的三种原因：

1.指针变量没有初始化，所有==指针在创建的时候不会被自动初始化为NULL的，缺省值是随机指向的==；

2.当指针==被free或者delete之后，没有指向NULL==，会不小心再次使用；

3.指针的操作超过了指针的作用范围，比如==不要返回指向栈内存的指针，因为在函数结束时栈内存会被释放==。



解决方法：

可以在声明指针的时候就指明地址：

```c
int a = 9;
int *p=&a;//初始化的时候就指向a变量的地址
printf("%d\n",*p);
```



## 8.29 输出源文件与当前执行的行数

问题：

如何输出源文件和当前执行的行数？写一个程序来实现。

分析：

<img src="../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/1598680892525.png" alt="1598680892525" style="zoom:200%;" />

要注意的是，宏定义左右都是==双下划线！！！==



代码如下：

```c
#include "stdio.h"

 int main( void )
 {
     int k;
     printf("Source file is %s\n",__FILE__);
     printf("Line number is %d\n",__LINE__);
     printf("Date is %s\n",__DATE__);
     printf("Time is %s\n",__TIME__);
     return 0;
 }

```

运行结果如下：

<img src="../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/1598681678483.png" alt="1598681678483" style="zoom:200%;" />



## 8.30 关系操作符

分析下面代码，求运行结果：

```c
int a = 20;

if( 1<=a<=10 ){
	printf("In range");
}
else{
	printf("Out of range");
}

```

主要考察的是`if( 1<=a<=10 )`的判断结果，由于是判断语句，所以结果就是真或者假，也就是1、0。

<=、>=是双目运算符，而且两者优先级相同，所以从左边开始结合，即先判断`1<=a`为真，也就是为1，接下来判断`1<=10`也自然为真，输出In range。



## 8.31 形参实参交换数据

判断下列程序的输出：

```c
void swap( int c, int d ){
    int t;
    t = c;
    c = d;
    d = t;
}

int main( void ){
    int a=2, b=3;
    swap( a, b );
    printf("%d,%d",a,b);
}

```

输出：2，3

这里涉及到形参与实参的区别，形参与实参的区别如下：
1.形参只在函数被调用的时候才会分配内存，调用结束后，一般情况释放内存，所以形参只在函数内部有效。

2.形参和实参必须在数量、位置、类型上一致。

3.函数调用中数据的传递方向是单向的，只能把实参的值传给形参，也就是一旦完成参数的传输，形参和实参就再也没有瓜葛了。

所以，对于这道题，swap( a, b )只是将a、b的值传给形参，在swap函数中，交换的是形参，与a、b没有关系，所以实际上a、b变量并没有完成交换。

如果要完成交换，可以将地址传进去，如下：

```c
void swap( int* c, int* d ){
    int t;
    t = *c;
    *c = *d;
    *d = t;
}

int main( void ){
    int a=2, b=3;
    swap( &a, &b );
    printf("%d,%d\n",a,b);
}

```

运行如下：
<img src="../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/1598839162176.png" alt="1598839162176" style="zoom:200%;" />



# 九月



## 9.1 数据类型转换

数据类型转换就是将数据从一种类型转换为另一种类型，数据可以是变量、数值、表达式等，数据类型的转换可以分为自动类型转换和强制类型转换。

> C语言中常量的默情况：整形默认为有符号int；浮点型默认为double;如果整形常量大小超出int，默认自然就为long int；如果需要无符号整形常量的话就可以在常量后面加u或是U，如0u或是0U，同理可以在常量后面加ul或UL表示无符号长整形常量；而浮点型常量后缀只有f或F，l或L，没有u或U，因为浮点数一般都为有符号 。
>
> L表示长整型、U表示无符号、F表示符点



**自动类型转换：**

自动类型转换就是编译器默认进行的类型转换，进行自动类型转换的情况一般如下：

1.当将一种类型的数据赋值给另一种类型的变量时，就会自动发送转换，赋值的时候会把右边的数据类型转换成左边的数据类型，但是这样可能导致数据失真或者精度降低，所以自动类型转换不一定是安全的。

```c
float f = 100;
int   k = f;

```

就像这样，先把100转换为float类型，然后赋值给f；再把f转换为int类型，赋值给k。

2.在不同数据类型的混合运算中，编译器也会自动转换数据类型，通常是将参与运算的数据先转换为同一种类型，然后进行运算，进行转换的规则如下：

* 按照数据长度增加的方向进行，以确保不丢失数据，比如int和long int参与的运算，会先把数据都转换为long int 类型的数据，然后进行运算。
* 所有的浮点运算都是按照双精度(double)进行的，即使运算中有float类型数据也要先转换为double，因为浮点数的默认类型是double。
* 在char与short 参与运算时，先要转换为int类型。

转换的图如下：
<img src="../../../%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6/Typora/%E5%9B%BE%E7%89%87%E5%BA%93/1598953660406.png" alt="1598953660406" style="zoom:150%;" />

**强制类型转换：**
强制类型转换就是在写代码的时候强制转化数据类型的，强制转换的格式为：

```c
(type_name) expression

```

`type_name`为新类型名称，为表达式。例如：

```c
(float) a;  //将变量 a 转换为 float 类型
(int)(x+y);  //把表达式 x+y 的结果转换为 int 整型
(float) 100;  //将数值 100（默认为int类型）转换为 float 类型

```

下面是一个需要强制类型转换的经典例子：

```c
#include <stdio.h>
int main(){    
    int sum = 103;  //总数    
    int count = 7;  //数目    
    double average;  //平均数    
    average = (double) sum / count;    
    printf("Average is %lf!\n", average);    
    return 0;
}

```

运行结果：

Average is 14.714286!
sum 和 count 都是 int 类型，如果不进行干预，那么的运算结果也是 int 类型，小数部分将被丢弃；虽然是 average 是 double 类型，可以接收小数部分，但是心有余力不足，小数部分提前就被“阉割”了，它只能接收到整数部分，这就导致除法运算的结果严重失真。
`sum / count`
在这段代码中，有两点需要注意：

* ==对于除法运算，如果除数和被除数都是整数，那么运算结果也是整数，小数部分将被直接丢弃；如果除数和被除数其中有一个是小数，那么运算结果也是小数。==
* ==`( )`的优先级高于`/`，对于表达式`(double) sum / count`，会先执行`(double) sum`，将 sum 转换为 double 类型，然后再进行除法运算，这样运算结果也是 double 类型，能够保留小数部分。注意不要写作`(double) (sum / count)`，这样写运算结果将是 3.000000，仍然不能保留小数部分。==

**类型转换只是临时性的**

无论是自动类型转换还是强制类型转换，都只是为了本次运算而进行的临时性转换，转换的结果也会保存到临时的内存空间，不会改变数据本来的类型或者值。请看下面的例子：

```c
#include <stdio.h>
int main(){    
    double total = 400.8;  //总价    
    int count = 5;  //数目    
    double unit;  //单价    
    int total_int = (int)total;    
    unit = total / count;    
    printf("total=%lf, total_int=%d, unit=%lf\n", total, total_int, unit);    
    return 0;
}

```

运行结果：

注意看第 6 行代码，total 变量被转换成了 int 类型才赋值给 total_int 变量，而这种转换并未影响 total 变量本身的类型和值。如果 total 的值变了，那么 total 的输出结果将变为 400.000000；如果 total 的类型变了，那么 unit 的输出结果将变为 80.000000。在C语言中，有些类型既可以自动转换，也可以强制转换，例如 int 到 double，float 到 int 等；而有些类型只能强制转换，不能自动转换，例如以后将要学到的 void * 到 int *，int 到 char * 等。

可以自动进行的类型转换一般风险较低，不会对程序带来严重的后果，例如，int 到 double 没有什么缺点，float 到 int 顶多是数值失真。只能强制进行的类型转换一般风险较高，或者行为匪夷所思，例如，char * 到 int * 就是很奇怪的一种转换，这会导致取得的值也很奇怪，再如，int 到 char * 就是风险极高的一种转换，一般会导致程序崩溃。



## 9.2 指向数组的指针

判断下列程序的输出：

```c
int main( void ){
    int a[5]={1,2,3,4,5};
    int *p=( int* )( &a+1 );
    printf( "%d,%d", *(a+1), *(p-1) );
}

```

结果输出：

2,5



首先，指针的声明格式如示：类型 * [类型限定符列表] 名称 [= 初始化器];

```c
int *a;
int k = 5;
a = &k;

```

第一行中声明了一个指向int类型的指针a；第二行中声明了一个int型变量k；第三行中将指针a指向变量k；

或者也可以在声明指针的时候就将对象的值赋值给指针：

```
int k=5, *a=&k;

```

需要注意的是，==虽然指针指向的变量可能是不同类型的，但是在内存中指针的空间大小都是一样的==，比如32位计算机中指针的大小通常是4Byte（32bit）。



然后，指针变量的加减运算与其数据类型有关（数据类型大小以字节为单位），比如上面的a++；k的地址就会加4，因为k是int，一般占4Byte。就像数组中一样，元素都是顺序排列的，+1就指向下一个元素。



在定义数组的时候，需要给出数组名和数组长度，数组名可以认为是被转换为了一个指针，指向数组的首个元素。但是！！！==数组名的本意表示的是整个数组，也就是表示数组所有元素的集合，在使用过程中经常会转换为指向第0个元素的指针，实际上数组名和数组首地址并不是等价的。==在绝大多数表达式中，数组名代表指向第0个元素的指针，有两种情况例外：

* sizeof返回整个数组所占用的字节，而不是数组第0个元素占用的字节
* ==单目操作符&作用于数组名时，返回一个指向数组的指针，而不是一个指向数组第0个元素的指针==



所以在这里：

```c
int *p = (int*)( &a+1 );

```

首先执行&a，==得到一个指向数组a整体的指针，然后&a+1代表在数组整体的基础上地址加一（这里的加一表示的是下一个元素的地址，并不是实际内存+1Byte，反而是实际内存+4Byte，在32位情况下），所以&a+1在逻辑上相当于a[5]，然后再通过( int* )强制转换为int类型指针，使p指针指向a[5]的地址（逻辑上）。==

所以在后面*(p-1)中，p相当于&a[5]，所以可以看作a[5-1]，即a[4]，答案为5





## 9.3 指针加法

运行这段程序：

```c
int main( void ){
    int *p=0;
    p++;
    printf("p=%d\n",p);
    return 0;
}

```

`int *p=0;`是定义了一个指向0地址的int型指针

`p++`代表指针指向下一个int型地址

int型数据占4Byte，所以下一个int型地址就是在上一个int地址的基础上＋4

所以此时p指向的地址就是0+4

即打印出p=4

> 注意：指针的大小是1Byte，指针指向的地址是根据数据类型有所不同的





## 9.4 预处理器（Preprocessor）

题目：

 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题 )?

分析：

一年有多少秒，365X24X60X60=31,536,000，但是如果运行的CPU是16位，16位无符号数的范围是0~65535，就会造成整型数据溢出，所以要将此数据声明为无符号长整型数据，即：

```c
#define YEAR_TIME (365*24*60*60)UL

```

加上UL声明为无符号整型数据！



## 9.5 数组作为参数的sizeof

题目：

在 32位系统下，执行如下代码，运算结果是多少？

```c
void func( char str[100]){
   printf("%d",sizeof( str ) );
}

int main(void){
    char str[] = "www.firebbs.cn";
    char *p = str ;
    int n = 10;
    printf("%d,%d,%d,",sizeof (str ),sizeof ( p ) ,sizeof ( n ) );
    func(str);
    return 0;
}

```

我都输出：

14，4，4，100

实际答案：

15，4，4，4



分析：

* `char str[] = "www.firebbs.cn";`注意str是一个数组，而且声明的时候是一个字符串，所以字符串最后还有一个结束符’\0’，所以sizeof(str)=14+1=15

* `char *p = str ;`，p只是一个指向str首地址的指针，所有指针的大小都是32bit（32位系统下），所以sizeof(p)=4

* `int n = 10;`，32位系统下的int一般为四个字节，即sizeof(n)=4

* ```c
  void func( char str[100]){
     printf("%d",sizeof( str ) );
  }
  
  ```

  传入函数之后，会把str当作指针处理，不会在栈里开辟100Byte的空间的，所以这里的str相当于一个char型的指针，32位下所有指针大小都是4Byte，所以sizeof(str)=4

==数组作为参数传入函数后，按照指针处理==



## 9.6 可变参数入栈的顺序

题目：

运行下列代码，求输出？

```c
int a=0, b=0;
printf("%d,%d,%d",a++,++b,a+b);

```

我的答案：

0，1，1

实际答案：
0，1，0

分析：
考察的是可变参数的入栈顺序，==可变参数的入栈顺序都是从右往左==。

所以先执行a+b，此时a=b=0，所以a+b=0

然后向左走，++b，先自增，再赋值，b=1

然后向左走，a++，先赋值，再自增，所以格式化输出的时候a=0，运行完代码之后a=1

> 注意：这里的可变参数针对的是所有的含可变参数的函数，其入栈顺序都是从右往左；赋值说的是向格式化输出的那个位置赋值，也就是%d所在的位置赋值。；==自然而然出栈顺序就是从左往右。== 参数入栈顺序是和具体编译器实现相关的。比如，Pascal语言中参数就是从左到右入栈的，有些语言中还可以通过修饰符进行指定，如Visual C++。 



[参考链接](https://blog.csdn.net/u014181676/article/details/22103265?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf)





## 9.7 逗号表达式的应用

题目：

运行如下代码，求b的结果是多少？

```c
int a,b;
a = b = 1;
b = a++, b++, ++a;

```

我的答案：

b=2

正确答案：

b=2

分析：
这里涉及到逗号运算符，逗号运算符的优先级是最低的， 逗号表达式的运算过程为：从左往右逐个计算表达式 。逗号运算符最为一个整体，最后的结果就是最右边的表达式。

在这里：`b = a++, b++, ++a;`依次从左往右执行各个表达式，先a++，是整行代码执行完毕之后才+1；然后是b++，也是整行代码执行完毕之后才+1；最后是++a，即a=a+1=2；逗号表达式的值就是最后一个表达式的值，即2.



再比如这段程序：

```c
char a = 8;
printf("%d",(a=3*5,a*4));

```

输出的是60

分析：逗号运算符，先执行表达式a=3*5，执行完毕a=15，然后执行下一个表达式`a *4`，得出15 *4=60。逗号表达式的值是最后一个表达式的运算结果，所以结果就是60.



## 9.8 有符号和无符号的大小比较

分析下列代码运行结果：

```c
int main( void ){
    int a = -1;
    unsigned int b = 1;
    if( a > b ){
        printf("1\n");
    }else{
        printf("0\n");
    }
    return 0;
}

```

我的答案：

0

正确答案：
1

分析：

==有符号和无符号的数值进行比较的时候，编译器会将有符号参数类型的转换为无符号数==的来进行比较

所以

a = 0Xffffffff

b = 0X00000001

则-1L   > 1UL，输出1。

如何正确表达有符号和无符号的大小？

在有符号前加上强制转换类型，比如`if( a > (int)b )`就可以正确判断了

平时==尽量避免使用unsigned与有符号的数据类型比较大小==。



注意：

* 1.在位运算、模运算、回绕溢出利用较多的算法实现中（比如各种加密学算法、编码、压缩算法等）

有符号数的符号位在进行位运算时候会造成一些迷惑，位运算中如果采用无符号数会大大减少处理问题时对语言上的思考，可以更专心关注实际问题。

*  2.在网络收发，串口读写时候使用无符号数

TCP/IP 经常遇到无符号数，比如IP的表示，我们可以用 ip2long 把点分十进制 ip 转成一个 unsigned int 来表示，这会带来很大方便。串口读写的流更多的是用 unsigned char ，最常见的一个问题是 unsigned char 可以避免日志输出时候按照有符号输出造成的 ‘0xff’ 迷惑人的前缀。

* 3.避免有符号数与无符号数的直接接触，包括比较，运算

无符号数与有符号数比较时，编译器会发出警告。同时编译器内部也存在一套默认的类型转换规则（编译器自动进行，用户无感知）。大致分为3类（如有错误请指正）（说明：在计算机里，负数使用反码表示的）

　　先顶一下规则：有符号（int），无符号（unsigned int），非无符号（除 int 与 unsigned int外的类型，如char，unsigned char），非有符号（与前面同理）。

　　有符号与无符号比较：有符号数会转换成无符号数来进行比较（如int 与 unsigned int 比较，int 转换成 unsigned int）。

　　有符号与非无符号数比较：非无符号转化成有符号（如int 与 unsigned char比较，unsigned char 转换成 int）。

　　无符号与非有符号数比较：非有符号转化成有符号（如unsigned int 与 char比较，char 转换成 unsigned int）。

* 4.不要只因为某个数不可能为负就用无符号数

因为这虽然看起来很合要求，但是当无符号溢出时候带来的问题却很可能致命。

[详细说明链接](https://blog.csdn.net/u010765526/article/details/73613815)

[不错的文章](https://www.cnblogs.com/sinpo828/p/10943157.html)



## 9.9 位域的占用空间

题目如下，求输出结果：

```c
struct test{
    char  a:3;
    short b:4;
    char  c:5;
};
printf("%d",sizeof(test));

```

答案是：2

分析：

这里涉及到位域，在定义结构体的时候，我们可以指定成员变量所占用的位数，这就是位域，一种数据结构。位域的产生是由于有些数据在存储的时候并不需要占用一个完整的字节，可能几个位就可以满足需求。

在成员变量后面加上:x来表示位域为x，有关位域我们作如下几点说明：

* 位域的宽度不可以超过成员变量的最大长度
* 只有int、signed int、unsigned int、_Bool这几种数据类型是被C99支持的，但是编译器在实现的时候扩展了char、signed char、unsigned char、enum这几种数据类型。
* 当相邻的成员类型相同时，而且成员的==位宽之和小于sizeof(数据类型)，成员是按照位宽挨着存储的==，直到；如果==位宽之和大于sizeof(数据类型)，超出的成员将从新的存储单元开始==，整体偏移量为该数据类型的整数倍，同时对于整个结构体还要考虑内存对齐。
* 当相邻的成员==类型不相同==时，不同的编译器有不同的实现。在==GCC中，会压缩存储。VC和VS则不会压缩==，是按照结构体内存对齐进行存储的。
* 如果成员之间穿插着==非位域成员，则不会进行压缩==。
* 位域成员往往不占用完整的字节，有时候也不处于字节的开头位置，因此使用`&`获取位域成员的地址是没有意义的，C语言也禁止这样做。地址是字节（Byte）的编号，而不是位（Bit）的编号。 

所以对于这道题，a占用了3bit，下一个成员和a类型不同，在GCC下是可以压缩的，占用4bit，再下一个占用5bit，一共占用12bit。内存对齐，就是2Byte。



[参考文章](http://c.biancheng.net/view/2037.html)



## 9.10 移位 异或 优先级

分析下列程序的结果：

```c
int a=6,b=4;
a^b<<2=?

```

求`a^b<<2`的值？

我的答案：8

正确答案：22

分析：
我开始以为^的优先级比<<的优先级高，所以先进行异或运算，然后进行移位，得到8。实际上<<的优先级要比^的优先级高，所以先进行移位运算，b<<2得到16，6^16得到22.

应该是`a^( b<<2 )`。



## 9.11 结构体元素偏移

```c
//int 占 2 个字节，char 占 1 个字节，float 占 4 个字节
struct stu{
    union{
        char bj[5];
        int  bn[2];
    }class;//5
    char  xm[8];//8
    float cj;//4
}xc;

```

问题：求sizeof(xc)?

我的答案：32

正确答案：20

分析：

无论结构体还是联合体，都讲究一个字节对齐，==按照其内部最大元素内存大小对齐！！！==

所以union中最大元素类型是int，这里是2字节，所以==union按照2字节对齐==，char bj[5]占了5字节，按照2字节对齐的时候再补一个字节，所以==union的大小是6Byte==；在struct中，class已经占了前6字节，==char xm[8]中每一个char占1字节，所以char数组可以紧接着存放8个字节==，现在内存大小为6+8=14字节，由于==float需要4字节对齐，所以float从第16字节开始存储，占用4字节==。至此struct内存大小占用20字节！

> 注意:结构体涉及数组的时候，我觉得可以把数组拆分开看作一个个元素，就好多了，只出现数组是不可以按照数组整体来内存对齐的.

结构体定义如下：

```c
//int 占 2 个字节，char 占 1 个字节，float 占 4 个字节
struct stu{
    union{
        char bj[5];
        int  bn[2];
    }class;//5
    char  xm[8];//8
    float cj;//4
}xc;

```

问题：若xc地址为0X1000，求&xm[0]的值？

我的答案：0X1006

根据上面的内容，union大小为6Byte，所以相对于结构体的偏移地址是6，则紧挨着的xm[0]的地址就是0X1000+6=0X1006



> 为了提高 CPU 的存储速度，编译器会对一些变量的起始地址做了“对齐”处理。
> 对齐方式（变量存放的起始地址相对于结构的起始地址的偏移量） 
> char    偏移量必须为 sizeof(char)  即 1 的倍数 
> int      偏移量必须为 sizeof(int)   即 4 的倍数  (跟编译器有关，有可能是 2)
> float  偏移量必须为 sizeof(float) 即 4 的倍数 
> double  偏移量必须为 sizeof(double) 即 8 的倍数 
> short  偏移量必须为 sizeof(short) 即 2 的倍数 





## 9.12 指针、数组的声明

题目：

用变量a给出下面的定义 

1、一个整型数（An integer）

 2、一个指向整型数的指针（ A pointer to an integer）

3、一个指向指针的的指针，它指向的指针是指向一个整数（ A pointer to a pointer to an intege）

4、一个有10个整型数的数组（ An array of 10 integers）

5、一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers）

 6、 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers）

 7、 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer） 

8、一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer 

答案：
1：`int a`

2：`int *a`

3：`int **a`

4：`int a[10]`

5：`int* a[10]`

6：`int (*a)[10]`

7：`int (*a)(int)`

8：`int (*a[10])(int)`

`[]`的优先级比`*`要高，所以可以根据题中的要求来判断`[]`和`*`的先后执行顺序。

比如5题：一个10个指针的数组，指针指向整型数；首先是一个10个元素的数组，所以首先a[10]，然后指定数组元素是指针指向整型，所以声明元素为`int *`。

再比如6题：一个指针，指向有10个整型数的数组；首先是一个指针，所以先声明指针，即`*a`，然后指针的指向是一个10个元素的整型数组，所以就成了`int (*a)[10]`。

当涉及到函数的时候，分为三部分：函数返回值类型、指向函数的类型、函数的参数类型。指向函数的格式就是加上一个括号，代表函数体。

所以7题分析为：返回值和参数都是整型数，所以`int () (int)`确定了两部分，然后是指向函数的指针，所以就有了`int (*a)(int)`

同理8题：返回值和参数都是整型，指向函数的是一个10个元素数组，数组的元素指向函数，所以就有`int (*a[10])(int)`



## 9.13 负数的求余运算

运行下列语句，求出x的值：

```c
int x=10;
x += 3+x%(-3);//x=x+3+x%(-3)=13+
```

 答案：14

分析：

`x += 3+x%(-3)`中，`+=`运算比较好判断，主要是`x%(-3)`的判断不知道是1还是-1，==在求余运算中，余数的符号与被除数的符号相同==，所以在这里x=10，则得数就是1，即`x += 3+1`易得x的值为14.



## 9.14 阅读代码

阅读下列代码，分析该代码的功能：

```c
char *func(char *dest, const char *src, int count)    
{    
    char *tmp = dest;    
    while (count) {    
        if ((*tmp = *src) != 0)    
            src++;    
        tmp++;    
        count--;    
    }    
    return dest;    
}   
```



分析：

先看参数和返回值，参数中第二个参数是const修饰的（指向的地址不可改变），所以第二个参数位置的字符串肯定是不能改变的，然后返回值也是一个char类型的指针，初步推断可能是一个字符串操作类的函数。

然后往函数内部分析，先创建了一个字符指针，指向传进来的dest

在while中根据count的大小进行遍历

` if ((*tmp = *src) != 0) `中，先是将`*tep = *src*`然后判断*tmp是否为空，相当于字符拷贝，然后自增、coun自减

可以看出此函数就是拷贝字符串的函数。

实际上strncpy的源码如下：

```c
/*   

 * strncpy - Copy a length-limited, %NUL-terminated string   

 * @dest: Where to copy the string to   

 * @src: Where to copy the string from   

 * @count: The maximum number of bytes to copy   

 *   

 * The result is not %NUL-terminated if the source exceeds   

 * @count bytes.   

 *   

 * In the case where the length of @src is less than that of   

 * count, the remainder of @dest will be padded with %NUL.   

 */   

char *strncpy(char *dest, const char *src, size_t count)    //从 src 复制count个字符 到 dest 
{    
    char *tmp = dest;    
    while (count) {    
        if ((*tmp = *src) != 0)    //把 src 的值 复制到 dest ，如果 src 的值 非空，那么指针自加。
                                   //否则 指针不加，src 后续都是指向 0 ，即字符串结束,后续的 dest值都为 0

            src++;    
        tmp++;                     // dest 的指针 自加
        count--;                   //最大计数值 减 1
    }    
    return dest;    c
}   
```


##  9.15 逗号表达式细节

求如下程序的输出：

```c
int a[3][2] = {(0,1),(2,3),(4,5)};
int *p = a[0];
printf("%d",p[0]);
```

答案：1

分析：
这里分析一下程序，p指针指向a[0]，也就是指向二维数组的首地址，所以p[0]的值就是二维数组的第一个值。

再看一下二维数组的定义：`int a[3][2]={(0,1),(2,3),(4,5)}`，这里要注意，这里的初始化不是分段赋值，正常的分段赋值应该是这样：`int a[3][2]={{0,1},{2,3},{4,5}}`，这里是逗号分隔的，所以是逗号表达式，实际的是连续赋值：`int a[3][2]={1,3,5}`，所以p[0]=1.


## 9.16 变量的存储布局

分析以下程序运行时各个变量的内存分布：

```c
int a = 0;//全局初始化区：.data
static int b = 20;//静态初始化区：.data
char *p1;//全局未初始化区：.bss
const int A = 10;//.rodata

int main(void) {
    int b;//栈
	char s[] = "abc";//栈
    char *p2;//栈
    static int c = 0;//静态初始化区：.data
    char *p3 = "123456";//.rodata  常量区  p3在栈
    p1 = (char*)malloc(10);//堆
    p2 = (char*)malloc(10);//堆
    strcpy( p1, "123456" );//123456\0 在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方
    
    return 0;
}
```

* 栈区（stack）：由编译器自动分配释放，放置函数的参数值和局部变量
* 堆区（heap）：一般由程序员分配释放，若不释放，程序结束时由系统释放
* 全局变量、静态变量(const)：放在.data段
* 未初始化的全局变量、静态变量：放在.bss段
* 文字常量：常量区，.rodata段，程序结束后由OS释放

全局变量 、静态变量初始值为0，局部变量，自动变量初始值随机分配值。

注意：

```c
void main()   
{   
    char *p="abcde";       //.rodata
    char a[]="abcde";      //.data
    p[1]='m';                  //错误，修改字符串常量
    a[1]='m';                  //正确，修改元素
}
```

static修饰全局变量是限制其作用域只在当前文件中，static修饰局部变量是扩展其作用域为当前文件，相当于全局变量。

## 9.17编译器角度看：数组、指针

数组名和指针是两个往往很容易让人们混淆的概念，很多人以为数组名就是一个指针，也有很多人知道数组名不同于指针但是仅知道数组名的值不能像指针一样改变，例如你可以写出下面这样的代码：

复制

```
int *p;
p++;
```

却不能写这样的代码：

复制

```
int a[];
a++;
```

那么数组名跟指针之间到底有什么区别呢？
**第一** ，在声明上，除了作为函数参数的数组名总是编译器转化成指针，其他情况下，数组名就是数组名，指针就是指针，二者不能混淆，你不能在一个文件中定义一个数组，而在另一个文件中把它声明成一个指针。 

```
char a[];  //定义一个数组a
 
extern char* a; //在另一个文件中将a声明成一个指针
```

在编译器中，符号表用来存放C语言中有关标识符的属性信息，这些信息集中反应了标识符的特征属性。等到词法分析到代码声称的各个阶段的时候，编译器需要根据源代码提出的要求，从表中获取不同标识符的不同属性。值得注意的是，数组标识符的属性和指针是完全不同的。因此，在一个文件中定义一个数组的时候，编译器会把它记录在符号表中，而在编译器分析另一个文件中的声明时，通过符号的语义检查发现不一致。也许这样的声明可以编译通过(在gcc下通过了)，但是把一个数组名当成一个指针来使用，别指望它能运行起来。

**第二**，指针是一个变量，而数组名不是。数组名是数组的首地址，即它本身就是一个地址，对应到汇编语言级别就是一个常量，一个固定的数（地址）。因此数组名不能进行++,--等运算。在大多数编译器中，对数组的引用a总是被编译器改写成*(a+i)的格式。也就是说，编译器每遇到a，都会把它当作*(a+i)来处理。我们都知道，*addr表示内存中（addr）的位置存储的值，比如*0x8048000就表示地址为0x8048000的内存中所存储的值。所以a就表示a的值加上i所得到的数作为一个内存地址里面所存储的值。



**第三**，对数组的引用，如a，或* (a+1)，需要访存一次；而对指针的引用，如* (p+1)，需要访存两次。如果理解了第二条的解释，这个应该就不难理解。因为a被认为是常数，所以取*(a+1)的值只需将a所表示的常数加1，然后从得到的地址里访存取一次即可。而对于指针，需要先从&p这个地址里把p的值取出来，然后加1，再从得到的地址里访存取一次，一共需要两次访存。

**第四**

 假设a是一个数组名，而p是一个指针，当你使用 a 和 &a 时，得到值是一样的，都是数组的起始地址。而使用 p 和 ＆p 时，得到的值是不一样的， p 表示指针 p 所指向的地址，而 &p 表示 p 这个变量的地址。再假设 

```
p = a;
```

则 p 就表示数组a的起始地址，而&p是存储数组a的起始地址的那个地址。



## 9.18 C++中类的定义

C++中，类是一个用户自定义的数据类型，形式如下：

```cpp
class name {
    成员列表
};
```

成员列表是类成员的集合，数目可以任意多对，类后面必须加上；作为结束。

* 类成员必须在内部声明，一旦类的定义完成之后，就没有任何其他方式增加减少成员了。
* 一般将数据成员封装起来，成员函数作为接口，==外部调用成员函数访问成员数据==。
* 类函数的==声明必须要在内部声明，但是定义可以在class内部，也可以在外部==。
* 内部定义的函数就是内联函数，此种定义方法与一般的函数定义无异。
* ==外部定义class函数的时候，必须要加上作用域==，以表明此定义的函数是某一个class中的成员函数。
* ==类相当于一种数据结构，数据类型是不占用空间的==，但是当用一个类实体化一个对象的时候，就会为对象分配存储空间。
* 类的空间大小取决于class中数据成员的大小，以及排布（==和struct的空间大小原理相似==）

## 9.19 C++中类成员的访问控制

对C++中成员的访问，就是访问数据或者函数，面向对象的编程中，经常把数据封装起来，通过调用成员函数；来访问成员数据。class中，每个成员的访问属性有：public、private、protected

* 成员数据一般为private，成员函数一般为public，外部通过public的成员函数来访问private的成员数据。

* class中默认为private



## 9.20 C++中构造函数

实体化一个对象的时候，一般要进行初始化操作，我们可以在class中写一个成员函数来初始化class成员数据，但是也可以直接使用构造函数来初始化成员数据（自动调用）。

* class中成员数据在定义的时候是不可以初始化的，即：`int a = 1;`是不允许的。
* 构造函数要和class名称一致，而且不能指定返回值。
* 构造函数是一种特殊的成员函数，不需要人为调用，在实体化对象的时候会自动调用执行。
* 没有构造函数class会报错，但是一般用户不声明构造函数的时候，IDE就会自动生成一个默认的构造函数

## 9.21数组、字符串的存取效率

在程序中，对数组和字符串的存取，哪个更有效率？

先看一段程序：

```c
#include "stdio.h"
int main() {
    char a = 1;
    char c[] = "123456789";
    char *p  = "123456789";
    a = c[1];
    a = p[1];
    return 0;
}

```

声明了一个数组c和一个字符串p，然后同样读取其中的一个值，对应的汇编代码如下：

```
10:a=c[1];
004010678A4DF1 movcl,byteptr[ebp-0Fh]
0040106A884DFC movbyteptr[ebp-4],cl
11:a=p[1];
0040106D8B55EC movedx,dwordptr[ebp-14h]
004010708A4201 moval,byteptr[edx+1]
004010738845FC movbyteptr[ebp-4],al
```

可以看出对于a = c[1]的操作，是直接将数组中字符串的元素读取到c1寄存器中（也就是a）

对于a = p[1]的操作，显示将指针的值edx中，再根据地址读取字符元素

所以数组的读取比字符串的读取要有效率，即在栈上的数组比指针指向的字符串要读取快。


## 9.22 求一个int数据 二进制中1的个数

```cpp
#include <iostream>
using namespace std;

int fun (int x) {
    int count = 0;
    while (x) {
        x &= (x-1);
        ++count;
    }
    return count;
}


int main() {
    int x = 0;
    cin>>x;
    cout<<"ans is :"<<fun(x)<<endl;
    return 0;
}
```

分析：把一个整数减去1，再和原整数做 & 运算，就会把整数最右边一个1变成0，通过while(x)来计数有多少个1.




## 9.23 指针与引用的区别

* 引用只是变量的一个别名，内部是依靠==只读指针实现的==，引用本身不占用内存空间，不能建立数组的引用
* 引用在初始化的时候就要指明赋值；而且指针可以在允许的情况下任意时刻赋值
* 引用不能为NULL；指针可以为NULL
* 引用保存的是==被引用变量的地址==
* `sizeof 引用`的大小是被==引用变量的大小==；`sizeof 指针`的大小是==指针本身的大小==
* ==引用在源代码级相当于一个普通的变量，但是作为函数参数时，传递的是变量地址==
* 指针可以有多级，引用只能一层

## 9.24 编写strcpy

**已知strcpy的函数原型：char *strcpy(char *strDest, const char *strSrc)其中strDest 是目的字符串，strSrc 是源字符串。不调用C++/C 的字符串库函数，请编写函数 strcpy。**

```cpp
#include <stdio.h>
#include <assert.h>

cahr* strcpy (char *strDest, const char *strSrc)
{
    assert ((strDest != NULL) && (strSrc != NULL));
    char *addr = strDset;
    while ((*strDest++ = *strSrc++) != '\0')；
        
    return addr;
}
```



* assert是宏，不是函数，其的原型定义在<assert.h>中，其作用是如果它的条件返回错误，则终止程序执行
* strcpy函数会连‘\0’一起拷贝
* 要用一个临时的变量保存目标字符串的首地址，最后返回这个临时变量
* 返回值为char* 是为了支持链式表达式



## 9.25引用作为函数参数的的注意

* 不能返回局部变量的引用
* 不能返回函数内部new产生的引用
* 传递引用给函数与传递指针给函数的效果一样，但是指针传递参数在函数中要分配空间的，而且在函数内使用指针变量名进行运算，程序的可读性会比较差
* 使用引用传递进来的参数，在函数运行过程中是没有产生实参的副本，是直接对地址进行操作的，所以当形参传递的数据比较大的时候，引用传递参数效果比较好



## 9.26 如何确认一段程序是C还是C++编译的

使用C++中的自定义宏来确定：

```cpp
#ifdef __cplusplus
	cout<<"C++"<<endl;
#else
    cout<<"C"<<endl;
#endif
```
## 9.27 给出各数据类型与零值比较的代码

分别给出BOOL，int，float，指针变量 与“零值”比较的 if 语句（假设变量名为var）

* 对于==逻辑判断==，使用`if (!var)`来判断是否为真
* 对于==整型数值判断==，使用`if (var == 0)`判断是否为0
* 对于==浮点型数值判断==，使用`if ((var >= 0.00001) && (var <= 0.00001))`之类的，进行一个范围判断
* 对于==指针判断==，使用`if (var == NULL)`来判断指针指向是否为空


## 9.28 C++程序中调用被C编译器编译后的函数，为什么要加extern”C”

由于C++支持函数重载，C不支持函数重载，而且函数的重载表面上看起来函数名一模一样，实际上C++编译器会在编译的时候给重载的函授根据参数的不同分配不同的名字，比如：

```cpp
void fun (int x, int y);
```

C编译器编译之后，该函数在库中的名字为：_foo

C++编译器编译之后，该函数在库中的名字为：_foo_int_int 

所以，为了区别这种名字匹配问题，C++提供了C链接交换指定符号extern “C”。当C++程序引用C的函数时，它会按照重载后的名字去目标文件（.obj）中去寻找对应的函数，而目标文件中存放的却是C版本的函数，名字对不上，所以根本找不到！




## 9.29 堆栈的区别详解

从以下几点分析堆栈的区别：
1.申请方式

2.申请后系统的响应

3.申请大小的限制

4.申请效率比较

5.存储的内容

6.存取效率比较

**1.申请方式**

stack：是由系统自动分配的，比如进入函数的参数、函数内声明的一些局部变量；

heap：由程序员申请的，C中经常用malloc函数（使用时要指明申请空间大小），C++中使用new函数；

要注意的是：`p = (int*) malloc (10)`中，==虽然申请的空间是堆上的，但是指针p在栈上，指向堆。==

**2.申请后系统的响应**

stack：只要申请的空间大于栈剩余的空间，系统就会自动为其提供空间，否则将报错栈溢出。

heap：操作系统有一个==记录空闲内存地址的链表==，当收到请求之后，会遍历链表，找到第一个空间大于申请空间的堆结点，将该结点的空间分配出去。当然，系统也==会记录分配出去的空间的首地址以及申请空间的大小，以便于后面释放空间。==

**3.申请大小限制**

stack：windows中是==向低地址扩展的数据结构，是一块连续的内存空间==。

heap：堆是==向高地址扩展的数据结构，由于系统用链表来存储空间地址，==所以不是连续的；链表的遍历方向是由低地址到高地址；==堆的大小取决于系统中有效的虚拟地址的大小。==

**4.申请效率的比较**

stack：由系统自动分配，速度快。

heap：由new分配的内存，速度比较慢，而且==容易产生内存碎片==，但是用起来方便。

**5.存储的内容**

stack：==函数调用的时候，第一个进栈的是函数调用语句之后的下一条可执行语句的地址，随后入栈的是函数的各个参数，遵循从右往左的入栈顺序（大多数情况），随后入栈的是函数中的局部变量；函数调用完毕之后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存储的地址，也就是第一个进栈的：函数调用语句之后的第一个可执行语句的地址，程序由该点继续运行。==

heap：一般在堆的头部用一个字节存放堆的大小，堆中的具体内容由程序员安排。

**6.存取效率的比较**

说明程序如下：

```c
int main ()
{
    char s1[] = "aaaaaaaa"; //字符串放在 栈
	char *s2  = "bbbbbbbb"; //字符串放在 常量区
    char s = 'c';
    
    s = s1[1];
    s = s2[1];
    
    return 0;
}
```

其中：`char s1[] = "aaaaaaaa";`是在函数运行的时候赋值的，`char *s2  = "bbbbbbbb";`是在编译的时候就确定的！而且在存取速度上来看，栈上的数据比常量区的字符串快。



## 9.30 volatile 详解

**volatile**是一个C语言关键字，修饰变量的时候表示：这个变量的值不可以被优化，==也就是说每次用到变量的值，都要去变量申请内存空间去，而不是去使用保存在寄存器中的备份。==

嵌入式程序员必须要知道的几点volatile的应用如下：

* 硬件寄存器的值，比如一些状态寄存器的值。

* 中断服务程序中访问到的一些非自动的变量，这些变量往往是反应程序运行状态或者是外部输入情况的，所以每一次的改变都要被记录下来。

* 多线程应用中被几个任务共享的变量。

下面通过几个例子来进一步熟悉volatile的用法：
例一：一个参数既可以是const又可以是volatile吗？

可以的，const表示变量不可以被程序修改，volatile表示变量每一次修改都要被记录。所以const和volatile可以同时用来修饰一个只读状态寄存器，只读的状态寄存器是不可以被程序修改的，而且寄存器的每一次改变都要被记录下来，不能被优化。



例二：一个指针可以是volatile吗？
可以的，当我们在中断服务程序中去修改一个指向字符串的指针的时候，就会用到volatile来修饰这个指针



例三：下列这段程序有什么错误？

```c
int square (volatile int *ptr)
{
    return *ptr * *ptr;  //返回平方值
}
```

首先返回值应该是long，要考虑到数据溢出。

其次，我们要明白，volatile修饰的变量就默认为会被意想不到的改变，所以而指针传进来的是一个地址，地址中的值可能随时改变。

然后，如果使用`*ptr * *ptr`进行平方运算，编译器会将代码优化为下列形式：

```c
int a, b;
a = *ptr;
b = *ptr;
return a * b;
```

这个时候由于*ptr的值可能被意想不到的改变，所以a、b的值可能不相同，会造成程序错误。

所以最好的方法就是一次将*ptr赋值给一个变量，然后去求这个变量的平方（利用自身乘以自身），程序如下：

```c
long square (volatile int *ptr)
{
    int a;
    a = *ptr;
    return a * a;
}
```

# 十月



## 10.1 内存碎片 



**内部碎片的产生：**因为所有的内存分配必须起始于可被 4、8 或 16 整除（视 处理器体系结构而定）的地址或者因为MMU的分页机制的限制，决定内存分配算法仅能把预定大小的内存块分配给客户。假设当某个客户请求一个 43 字节的内存块时，因为没有适合大小的内存，所以它可能会获得 44字节、48字节等稍大一点的字节，因此由所需大小四舍五入而产生的多余空间就叫内部碎片。

**外部碎片的产生：** 频繁的分配与回收物理页面会导致大量的、连续且小的页面块夹杂在已分配的页面中间，就会产生外部碎片。假 设有一块一共有100个单位的连续空闲内存空间，范围是0~99。如果你从中申请一块内存，如10个单位，那么申请出来的内存块就为0~9区间。这时候你 继续申请一块内存，比如说5个单位大，第二块得到的内存块就应该为10~14区间。如果你把第一块内存块释放，然后再申请一块大于10个单位的内存块，比 如说20个单位。因为刚被释放的内存块不能满足新的请求，所以只能从15开始分配出20个单位的内存块。现在整个内存空间的状态是0~9空闲，10~14 被占用，15~24被占用，25~99空闲。其中0~9就是一个内存碎片了。如果10~14一直被占用，而以后申请的空间都大于10个单位，那么0~9就 永远用不上了，变成外部碎片。



## 10.2 数组、字符串

```cpp
char str1[] = "abc";
char str2[] = "abc";
const char str3[] = "abc";
const char str4[] = "abc";
const char *str5 = "abc";
const char *str6 = "abc";
char *str7 = "abc";
char *str8 = "abc";

cout << ( str1 == str2 ) << endl;
cout << ( str3 == str4 ) << endl;
cout << ( str5 == str6 ) << endl;
cout << ( str7 == str8 ) << endl;
```

判断如上程序的输出：
0  0  1  1

原因是str1、2、3、4都是数组变量，strx代表数组的首地址，而数组里面的内容都是栈上面的，所以指向各不相同；但是str5、6、7、8是指针变量，指向的是字符串常量，相同的字符串在常量区的地址都是一样的。




## 10.3 越界读写字符串

分析如下程序：

```c
int main (void)
{
    char a = 'a';
    char *str = &a;
    
    strcpy(str, "Hello C");
    printf(str);
    
    return 0;
}
```

指针str指向变量a的地址，后面又将字符串“Hello C”复制在指针所指向地址上，虽然可能正常输出结果，但是会因为越界读写内存造成程序崩溃。




## 10.4 malloc内存泄漏+free非法访问+二级指针传参

程序如下：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void GetMemory(char *p)
{
    p = (char*)malloc(100);
    
    strcpy(p, "Hello world");
}

int main(void)
{
    char *str = NULL;
    
    GetMemory(str);
    printf("%s\n", str);
    free(str);
    
    return 0;
}
```

程序会崩溃，原因：malloc指向了新地址导致内存泄漏和free导致访问非法内存

**首先要明白如下概念：**

**C函数的所有参数都是传值调用，即函数会获得参数值的一份拷贝！！！即函数可以修改传递进来的参数值，而不必担心会影响到调用程序实际传给函数的参数值。**

**如果参数是数组名，函数中就可以通过访问数组下标来修改数组中的元素，这样岂不是函数可以修改调用程序实际传给函数的参数值吗？这样岂不是与上面所说：函数获得的只是参数值的一份拷贝，不会修改原参数值的说法吗？**

**实际上这种情况也是符合上述说法的，数组参数传递的是数组名，实际数组名的值就是一个指针，指针的值就是地址，强调一下，是地址！！！所以函数获取的还是数组地址的一份拷贝，在函数中通过这份拷贝的地址同样可以访问到原数组中的元素，从而修改数组的元素。**

==回归到程序上==：指针p传递的其实就是str地址的一份拷贝，在函数中修改了p指针的指向（指向malloc函数分配内存空间），对原来的str指针造不成丝毫影响。因为没有在str指向的地址上进行修改，而是在新的地址上进行修改（strcpy），所以对原来的str所指向的地址空间造不成任何影响。即str指向的还是NULL，但是对一个NULL指针进行free操作就是==非法访问==了。而且在malloc之后没有进行free释放内存空间，也造成了==内存泄漏==。



**解决方法：**

使用二级指针传递参数，什么时候用到二级指针呢？就是**在函数外定义一个指针，在函数内给指针赋值，要求函数结束后指针的赋值生效，这样就需要二级指针！**

对于参数传递来说，传递进入函数的始终是参数的一个副本（拷贝值）。**所以一级指针作为参数时，传入的是指针指向地址的副本，随后malloc改变的是副本的值，malloc作用不到原始指针；==二级指针作为参数时，传入的是指针变量本身地址的副本，malloc改变的是基于原指针地址上的指向的地址==，所以可以作用到原指针；**

修改后的程序如下：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void GetMemory(char **p)       //参数 char **p 传递的是指针变量的地址
{
    *p = (char*)malloc(100);   //malloc修改的是基于原指针变量的指向的地址，所以可以作用到原指针
    strcpy(*p, "Hello world");
}

int main(void)
{
    char *str = NULL;

    GetMemory(&str);           //传入的是指针变量的地址
    printf("%s\n", str);
    free(str);                 //释放内存空间

    return 0;
}
```





> free:
>
> 传递给free的指针必须是从malloc、calloc、realloc返回的指针，否则让free释放一块非动态分配的内存可能导致程序立即终止或者晚些时候终止。有时候使用free释放一块动态分配的内存的一部分也可能引起这种错误。注意：不要访问free释放的内存。
>
> 内存泄漏:
>
> 内存泄漏是指内存被动态分配之后，当它不再使用时未被释放就会造成内存泄漏。内存泄漏回增加程序的体积，还有可能导致程序或者系统的崩溃。




## 10.5 求含位域的结构体大小

```c
struct s1
{
    int a : 8;
    int b : 4;
    int c : 3;
    double d;
};

struct s2
{
    int a : 8;
    int b : 4;
    double c;
    char d : 3;
};

struct s3
{
    int a : 5;
    int b : 6;
};


```

s1 = 2+6+8=16

a、b、c一共占2Byte；前三个对齐后再加6Byte；d占8Byte

s2 = 2+6+8+8=24

a、b一共占2Byte；对齐后再加6Byte；c占8Byte；d对齐后占8Byte

s3 = 1+1+2=4

对齐后占4Byte

